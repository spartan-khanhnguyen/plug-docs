---
title: Python SDK
description: Complete guide for integrating SnapPay with Python applications using async patterns
---

## Overview

The SnapPay Python SDK provides a comprehensive, async-first interface for integrating payment processing, subscription management, and real-time event streaming into your Python applications. Built with modern asyncio patterns and type safety, it offers seamless integration with SnapPay's platform.

**Requirements:** Python 3.8+

### Key Features

- **Async-first design** with aiohttp for optimal performance
- **Context manager support** for automatic session management
- **Real-time event streaming** via Server-Sent Events (SSE)
- **Full type safety** with TypedDict definitions
- **Service-based architecture** for organized functionality
- **Automatic retry logic** and error handling
- **Environment-based configuration**

## Installation

```bash
pip install snappay
```

## Configuration & Initialization

The SDK is configured through environment variables and the client's constructor. All operations require proper authentication and should use the async context manager pattern for optimal resource management.

### API Key Authentication

Authentication is handled via an API key that must start with `pk_test_` (for testing) or `pk_live_` (for production). Configure your API key in one of these ways:

**Environment Variable (Recommended):**

```bash
export SNAPPAY_API_KEY="pk_test_xxxxxxxxxx"
```

**Direct Configuration:**

```python
import asyncio
from snappay import SnapPay

async def main():
    # Using environment variable (recommended)
    async with SnapPay() as client:
        customer = await client.get_customer("cus_123", email="user@example.com")

    # Using direct API key
    async with SnapPay(api_key="pk_test_xxxxxxxxxx") as client:
        customer = await client.get_customer("cus_123", email="user@example.com")

asyncio.run(main())
```

### Advanced Configuration

```python
from snappay import SnapPay, SnapPayConfig
from snappay.config import RetryConfig, TimeoutConfig

config = SnapPayConfig(
    api_key="pk_test_xxxxxxxxxx",
    base_url="https://api.snappay.dev",  # Custom base URL
    retry=RetryConfig(max_retries=5, base_delay=1.0),
    timeout=TimeoutConfig(total=30, connect=10),
)

async with SnapPay(config=config) as client:
    # Use configured client
    pass
```

## Core Methods

All methods are async coroutines and must be called with `await`. The SDK uses a service-based architecture where methods are organized into logical groups: `customers`, `checkout`, `access`, and `usage`.

### Customer Management

#### customers.get

Retrieves or creates a customer record (upsert logic).

```python
from snappay import SnapPay

async with SnapPay() as client:
    customer = await client.customers.get(
        cusId="cus_123",
        email="user@example.com",
        name="John Doe"  # Optional
    )
    print(f"Customer ID: {customer['customer_id']}")
```

**Parameters:**

- `cusId` (str): Customer identifier
- `email` (Optional[str]): Customer email address
- `name` (Optional[str]): Customer full name

**Returns:** `Customer` object with:

- `customer_id` (str): SnapPay customer ID
- `email` (str): Customer email
- `name` (Optional[str]): Customer name
- `status` (str): Customer account status
- `env` (str): Environment (test/live)
- `stripe_customer_id` (Optional[str]): Stripe customer ID
- `created_at` (Optional[str]): Creation timestamp
- `updated_at` (Optional[str]): Last update timestamp

### Checkout Sessions

#### checkout.create_session

Creates a payment checkout session URL for customer purchases.

```python
from snappay import SnapPay, Provider

async with SnapPay() as client:
    session = await client.checkout.create_session(
        customer_id="cus_123",
        product_id="premium-plan",
        success_url="https://yourapp.com/success",
        cancel_url="https://yourapp.com/cancel",  # Optional
        provider=Provider.STRIPE,  # Default: STRIPE
        # Additional checkout parameters
        metadata={"order_id": "ord_456"}
    )
    print(f"Checkout URL: {session['url']}")
```

**Parameters:**

- `customer_id` (str): SnapPay customer ID
- `product_id` (str): Product ID from your SnapPay dashboard
- `success_url` (str): URL to redirect after successful payment
- `cancel_url` (Optional[str]): URL to redirect on cancellation
- `provider` (Provider): Payment provider (defaults to STRIPE)
- `**kwargs`: Additional checkout session parameters

**Returns:** `CheckoutSession` object with:

- `session_id` (str): Unique session identifier
- `url` (str): Checkout URL for customer
- `expires_at` (str): Session expiration timestamp
  (additional fields may be present depending on server response)

### Access Control

#### access.check

Checks if a customer has access to a specific feature based on their subscription and usage limits.

```python
from snappay import SnapPay

async with SnapPay() as client:
    access = await client.access.check(
        customer_id="cus_123",
        feature_id="premium-features"
    )

    if access["has_access"]:
        allowance = access.get("allowance")
        usage = access.get("usage")
        if allowance is not None and usage is not None:
            print(f"Access granted. {usage}/{allowance} used")
        else:
            print("Access granted (unlimited feature)")
    else:
        print("Access denied. Upgrade required.")
```

**Parameters:**

- `customer_id` (str): SnapPay customer ID
- `feature_id` (str): Feature identifier

**Returns:** `AccessCheck` object with:

- `has_access` (bool): Whether customer has access
- `feature_id` (str): Feature being checked
- `usage` (Optional[int]): Total usage
- `allowance` (Optional[int]): Maximum usage allowed
- `next_reset_at` (Optional[int]): Next reset timestamp

### Usage Tracking

#### usage.track

Reports usage for a metered feature. This action is idempotent to prevent duplicate tracking.

```python
from snappay import SnapPay

async with SnapPay() as client:
    result = await client.usage.track(
        customer_id="cus_123",
        feature_id="ai-messages",
        usage=1,  # or 1.5 for fractional usage
        idempotency_key="unique-operation-123"  # Optional
    )
    print(f"Usage tracked successfully: {result}")
```

**Parameters:**

- `customer_id` (str): SnapPay customer ID
- `feature_id` (str): Feature identifier for usage tracking
- `usage` (Union[int, float]): Usage amount to track
- `idempotency_key` (Optional[str]): Prevents duplicate tracking

**Returns:** `TrackUsageResponse` object with tracking confirmation details.

#### usage.get

Retrieves current usage details for a customer's feature.

```python
from snappay import SnapPay

async with SnapPay() as client:
    usage_list = await client.usage.get(
        customer_id="cus_123",
        feature_id="ai-messages"
    )
    # API may return multiple records; iterate or select first
    for usage in usage_list:
        print(f"Total usage: {usage['total_usage']}")
        if usage.get('remaining') is not None:
            print(f"Remaining: {usage['remaining']}")
        if usage.get('limit') is not None:
            print(f"Limit: {usage['limit']}")
```

**Parameters:**

- `customer_id` (str): SnapPay customer ID
- `feature_id` (str): Feature identifier

**Returns:** `GetUsageResponse` object with current usage and limits.

## Real-time Event Handling

SnapPay provides real-time events via Server-Sent Events (SSE). Subscribe to standardized backend events without managing webhooks.

### ðŸš« What You DON'T Need:

- **No webhook endpoints** to create and maintain
- **No webhook signature verification**
- **No webhook retry logic** or failure handling
- **No webhook security concerns**
- **No debugging webhook delivery issues**

### âœ… What You GET:

- **Real-time events** delivered instantly to your application
- **Guaranteed delivery** with automatic reconnection
- **Clean, structured data** - no raw webhook payloads
- **Multiple consumption patterns** to fit your architecture
- **Type-safe event objects** with full IDE support

### Stream Events (Async Generator)

```python
import asyncio
from snappay import SnapPay

async def main():
    async with SnapPay() as client:
        async for event in client.stream_events():
            print(f"Event: {event.type}")
            print(f"ID: {event.id}")
            print(f"Data: {event.data}")

asyncio.run(main())
```

### Event Handlers

```python
import asyncio
from snappay import SnapPay, SSEEvent, SSEEventType

def handle_subscription_updated(event: SSEEvent):
    print(f"Subscription updated: {event.data}")

def handle_any(event: SSEEvent):
    print(f"Event: {event.type} -> {event.data}")

async def main():
    async with SnapPay() as client:
        client.on_event(SSEEventType.SUBSCRIPTION_UPDATED, handle_subscription_updated)
        client.on_any_event(handle_any)
        await client.start_events()
        await asyncio.sleep(60)
        await client.stop_events()

asyncio.run(main())
```

### Event Structure

`SSEEvent` instances provide a normalized structure:

```python
from snappay import SSEEvent

event = SSEEvent(
    id="evt_123456",        # Unique event identifier
    type="SUBSCRIPTION_UPDATED",
    data={"customerId": "cus_123", "productId": "pro_456"},
    created_at="2024-01-01T10:00:00Z",
)
```

### Advanced Event Configuration

```python
from snappay import SnapPay

async def main():
    async with SnapPay() as client:
        # Configure SSE client
        client.events(reconnect_interval=5, max_reconnect_attempts=10)

        # Stream with configuration
        async for event in client.stream_events(
            reconnect_interval=5,
            max_reconnect_attempts=10,
            include_system_events=False,
        ):
            print(f"Event: {event.type}")

asyncio.run(main())
```

### Production Considerations

- Use `client.on_event(SSEEventType.HEARTBEAT, ...)` to handle heartbeats if needed.
- Use `client.on_any_event(handler)` to observe all events.
- Configure reconnection via `SnapPayConfig().sse` or `client.events(...)`.

**Key Benefits Demonstrated:**

- âœ… **Zero webhook infrastructure** - no endpoints, no servers, no security concerns
- âœ… **Instant event processing** - no webhook delivery delays or failures
- âœ… **Simplified error handling** - no webhook verification or retry logic needed
- âœ… **Clean separation of concerns** - focus on business logic, not webhook plumbing

## Type Definitions

The SDK provides comprehensive type definitions using `typing.TypedDict` for full type safety and excellent IDE support:

```python
from typing import TypedDict, Optional, Union, Dict, Any
from snappay.types import (
    Customer, CheckoutSession, AccessCheck,
    TrackUsageResponse, GetUsageResponse, Provider
)
from snappay import SSEEvent

# Core response types
class Customer(TypedDict, total=False):
    customer_id: str
    email: str
    name: Optional[str]
    status: str
    env: str
    created_at: Optional[str]
    updated_at: Optional[str]
    metadata: Optional[Dict[str, Any]]
    stripe_customer_id: Optional[str]
    deleted: Optional[bool]

class CheckoutSession(TypedDict, total=False):
    session_id: str
    url: str
    expires_at: str
    status: Optional[str]
    customer_id: Optional[str]
    product_id: Optional[str]
    success_url: Optional[str]
    cancel_url: Optional[str]
    provider: Optional[str]

class AccessCheck(TypedDict, total=False):
    has_access: bool
    feature_id: str
    usage: Optional[int]
    allowance: Optional[int]
    next_reset_at: Optional[int]

# Event class
# from snappay import SSEEvent (class with id, type, data, created_at)

# Enums
class Provider(Enum):
    STRIPE = "stripe"
```

## Error Handling

The SDK provides a comprehensive exception hierarchy for robust error handling:

```python
import asyncio
from snappay import (
    SnapPay, SnapPayError, AuthenticationError,
    ValidationError, RateLimitError, NotFoundError,
    ConflictError, PaymentError, ServerError
)

async def comprehensive_error_handling():
    async with SnapPay() as client:
        try:
            await client.get_customer("cus_123", email="test@example.com")

        except AuthenticationError as e:
            print(f"Invalid API key: {e}")

        except ValidationError as e:
            print(f"Invalid parameters: {e}")

        except RateLimitError as e:
            print(f"Rate limit exceeded: {e}")

        except NotFoundError as e:
            print(f"Resource not found: {e}")

        except ConflictError as e:
            print(f"Resource conflict: {e}")

        except PaymentError as e:
            print(f"Payment processing error: {e}")

        except ServerError as e:
            print(f"Server error: {e}")

        except SnapPayError as e:
            print(f"General SnapPay error: {e}")

        except Exception as e:
            print(f"Unexpected error: {e}")

asyncio.run(comprehensive_error_handling())
```

### Exception Hierarchy

```python
SnapPayError                    # Base exception
â”œâ”€â”€ AuthenticationError          # Invalid API key or authentication
â”œâ”€â”€ ValidationError              # Invalid parameters or request data
â”œâ”€â”€ RateLimitError              # API rate limit exceeded
â”œâ”€â”€ NotFoundError               # Resource not found
â”œâ”€â”€ ConflictError               # Resource conflict (e.g., duplicate)
â”œâ”€â”€ PaymentError                # Payment processing failures
â””â”€â”€ ServerError                 # Server-side errors (5xx responses)
```

## Complete Integration Example

Here's a comprehensive example showing all major SDK features:

```python
import asyncio
from snappay import SnapPay, Provider, SSEEventType

async def main():
    async with SnapPay() as client:
        try:
            # 1. Customer Management
            customer = await client.customers.get(
                cusId="customer_123",
                email="customer@example.com",
                name="John Doe"
            )
            print(f"Customer ID: {customer['customer_id']}")

            # 2. Create Checkout Session
            checkout = await client.checkout.create_session(
                customer_id=customer["customer_id"],
                product_id="premium-plan",
                success_url="https://yourapp.com/success",
                cancel_url="https://yourapp.com/cancel",
                provider=Provider.STRIPE
            )
            print(f"Checkout URL: {checkout['url']}")

            # 3. Check Access (after customer completes purchase)
            access = await client.access.check(
                customer_id=customer["customer_id"],
                feature_id="premium-features"
            )

            if access["has_access"]:
                print("Customer has access!")

                # 4. Track Feature Usage
                await client.usage.track(
                    customer_id=customer["customer_id"],
                    feature_id="api-calls",
                    usage=1,
                    idempotency_key="unique-operation-456"
                )

                # 5. Get Usage Statistics
                usage_list = await client.usage.get(
                    customer_id=customer["customer_id"],
                    feature_id="api-calls"
                )
                if usage_list:
                    usage = usage_list[0]
                    print(f"API calls used: {usage['total_usage']}")
                    if usage.get('remaining') is not None:
                        print(f"Remaining: {usage['remaining']}")
            else:
                print("Customer needs to upgrade for access")

        except Exception as e:
            print(f"Error: {e}")

async def with_real_time_events():
    async with SnapPay() as client:
        client.on_event(SSEEventType.SUBSCRIPTION_UPDATED,
                        lambda e: print(f"Subscription updated: {e.data}"))
        await client.start_events()
        await asyncio.sleep(60)
        await client.stop_events()

if __name__ == "__main__":
    asyncio.run(main())
    # Or run with events
    # asyncio.run(with_real_time_events())
```

## Service-Based Architecture

For more advanced usage, you can access services directly:

```python
async def advanced_usage():
    async with SnapPay() as client:
        # Access individual services
        customer_service = client.customers
        checkout_service = client.checkout
        access_service = client.access
        usage_service = client.usage

        # Use services directly (same methods as client)
        customer = await customer_service.get("cus_123")
        access = await access_service.check("cus_123", "feature_123")
```

This completes the SnapPay Python SDK documentation. The SDK provides a powerful, type-safe, and async-first interface for payment and subscription management.
