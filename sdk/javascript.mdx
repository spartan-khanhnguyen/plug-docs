---
title: JavaScript SDK
description: Complete guide for integrating SnapPay with JavaScript/Node.js applications using modern async patterns
---

## Overview

The SnapPay JavaScript SDK provides a comprehensive interface for integrating payment processing, subscription management, and real-time event streaming into your JavaScript/Node.js applications. Built with modern async/await patterns and robust error handling, it offers seamless integration with SnapPay's complete platform.

**Requirements:** Node.js 18+

### Key Features

- **Modern async/await design** with fetch API for optimal performance
- **Comprehensive error handling** with typed error responses
- **Real-time event streaming** via Server-Sent Events (SSE)
- **Service-based architecture** for organized functionality
- **Automatic retry logic** and error handling
- **Environment-based configuration**
- **TypeScript support** with full type definitions

## Installation

```bash
npm install @snappay/sdk
```

## Configuration & Initialization

The SDK is configured through environment variables and the client's constructor. All operations require proper authentication and should use async/await patterns for optimal resource management.

### API Key Authentication

Authentication is handled via an API key that must start with `pk_test_` (for testing) or `pk_live_` (for production). Configure your API key in one of these ways:

**Environment Variable (Recommended):**

```bash
export SNAPPAY_API_KEY="pk_test_xxxxxxxxxx"
```

**Direct Configuration:**

```javascript
import { SnapPay } from "@snappay/sdk";

// Using environment variable (recommended)
const client = new SnapPay();

// Using direct API key
const clientWithKey = new SnapPay("pk_test_xxxxxxxxxx");
```

### Advanced Configuration

```javascript
import { SnapPay } from "@snappay/sdk";

// Constructor: new SnapPay(apiKey?: string, baseUrl?: string)
const client = new SnapPay("pk_test_xxxxxxxxxx", "https://api.snappay.dev");
```

## Core Methods

All methods are async functions that return promises and must be called with `await`. The SDK uses a service-based architecture where methods are organized into logical groups: `customers`, `checkout`, `access`, and `usage`.

### Customer Management

#### customers.get

Retrieves or creates a customer record (upsert logic).

```javascript
const result = await client.customers.get(
  "cus_123",
  "user@example.com",
  "John Doe"
);
if (!result.ok) {
  console.error(result.error.message);
} else {
  const customer = result.data;
  console.log(`Customer ID: ${customer.cus_id}`);
}
```

**Parameters:**

- `customerId` (string): Customer identifier
- `email` (string, optional): Customer email address
- `name` (string, optional): Customer full name

**Returns:** `Customer` object with:

- `customerId` (string): SnapPay customer ID
- `email` (string): Customer email
- `name` (string): Customer name
- `status` (string): Customer account status

### Checkout Sessions

#### checkout.createSession

Creates a payment checkout session URL for customer purchases.

```javascript
import { Provider } from "@snappay/sdk";

const result = await client.checkout.createSession(
  "cus_123",
  "premium-plan",
  "https://yourapp.com/success",
  "https://yourapp.com/cancel", // Optional
  null, // Optional priceId
  Provider.STRIPE, // Default
  { metadata: { order_id: "ord_456" } }
);
if (!result.ok) {
  console.error(result.error.message);
} else {
  console.log(`Checkout URL: ${result.data.url}`);
}
```

**Parameters:**

- `customerId` (string): SnapPay customer ID
- `productId` (string): Product ID from your SnapPay dashboard
- `successUrl` (string): URL to redirect after successful payment
- `cancelUrl` (string, optional): URL to redirect on cancellation
- `provider` (Provider): Payment provider (defaults to STRIPE)
- Additional checkout session parameters

**Returns:** `CheckoutSession` object with:

- `sessionId` (string): Unique session identifier
- `url` (string): Checkout URL for customer
- `expiresAt` (string): Session expiration timestamp

### Access Control

#### access.check

Checks if a customer has access to a specific feature based on their subscription and usage limits.

```javascript
const result = await client.access.check("cus_123", "premium-features");
if (!result.ok) {
  console.error(result.error.message);
} else {
  const access = result.data;
  if (access.hasAccess) {
    const { usage, allowance } = access;
    if (usage != null && allowance != null) {
      console.log(`Access granted. ${usage}/${allowance} used`);
    } else {
      console.log("Access granted (unlimited feature)");
    }
  } else {
    console.log("Access denied. Upgrade required.");
  }
}
```

**Parameters:**

- `customerId` (string): SnapPay customer ID
- `featureId` (string): Feature identifier

**Returns:** `AccessCheck` object with:

- `hasAccess` (boolean): Whether customer has access
- `featureId` (string): Feature being checked
- `usage` (number | null): Current usage (null if unlimited/no access)
- `allowance` (number | null): Usage limit (null if unlimited/no access)
- `nextResetAt` (number | null): Next reset timestamp (epoch seconds)

### Usage Tracking

#### usage.track

Reports usage for a metered feature. This action is idempotent to prevent duplicate tracking.

```javascript
const result = await client.usage.track({
  customerId: "cus_123",
  featureId: "ai-messages",
  usage: 1, // or 1.5 for fractional usage
  idempotencyKey: "unique-operation-123", // Optional
});
if (!result.ok) {
  console.error(result.error.message);
} else {
  console.log(`Usage tracked successfully: ${result.data.success}`);
}
```

**Parameters:**

- `customerId` (string): SnapPay customer ID
- `featureId` (string): Feature identifier for usage tracking
- `usage` (number): Usage amount to track
- `idempotencyKey` (string, optional): Prevents duplicate tracking

**Returns:** `TrackUsageResponse` object with tracking confirmation details.

#### usage.get

Retrieves current usage details for a customer's feature.

```javascript
const result = await client.usage.get({
  customerId: "cus_123",
  featureId: "ai-messages",
});
if (!result.ok) {
  console.error(result.error.message);
} else {
  const items = result.data;
  for (const usage of items) {
    console.log(`Total usage: ${usage.totalUsage}`);
    if (usage.remaining != null) console.log(`Remaining: ${usage.remaining}`);
    if (usage.limit != null) console.log(`Limit: ${usage.limit}`);
  }
}
```

**Parameters:**

- `customerId` (string): SnapPay customer ID
- `featureId` (string): Feature identifier

**Returns:** `GetUsageResponse[]` array with items containing:

- `totalUsage` (number)
- `productId` (string)
- `featureId` (string)
- `remaining` (number | null)
- `limit` (number | null)
- `nextResetAt` (number | null)

## Real-time Event Handling

**Say goodbye to webhook hell!** SnapPay eliminates the complexity of managing payment webhooks by processing all provider webhooks (Stripe, PayPal, etc.) internally and delivering clean, structured events directly to your application via Server-Sent Events (SSE).

### ðŸš« What You DON'T Need:

- **No webhook endpoints** to create and maintain
- **No webhook signature verification**
- **No webhook retry logic** or failure handling
- **No webhook security concerns**
- **No debugging webhook delivery issues**

### âœ… What You GET:

- **Real-time events** delivered instantly to your application
- **Guaranteed delivery** with automatic reconnection
- **Clean, structured data** - no raw webhook payloads
- **Multiple consumption patterns** to fit your architecture
- **Type-safe event objects** with full IDE support

### Stream Events (Async Iterator)

Simply iterate over events as they arrive - SnapPay handles all the webhook complexity behind the scenes:

```javascript
import { SnapPay } from "@snappay/sdk";

async function main() {
  const client = new SnapPay();
  for await (const event of client.streamEvents()) {
    console.log(`Event: ${event.type}`);
    console.log(`ID: ${event.id}`);
    console.log(`Data:`, event.data);
  }
}

main().catch(console.error);
```

### Event Handlers

Set up handlers for specific payment events - SnapPay converts complex webhook payloads into simple, actionable events:

```javascript
import { SnapPay, SSEEventType } from "@snappay/sdk";

function handleSubscriptionUpdated(event) {
  console.log("Subscription updated:", event.data);
}

function handleAny(event) {
  console.log("Event:", event.type, event.data);
}

async function main() {
  const client = new SnapPay();
  client.on(SSEEventType.SUBSCRIPTION_UPDATED, handleSubscriptionUpdated);
  client.on("*", handleAny);
  await client.startEvents();
  await new Promise((resolve) => setTimeout(resolve, 60000));
}

main().catch(console.error);
```

### Event Structure

SSE events are normalized to a discriminated union with three types:

```ts
type SSEEvent =
  | {
      readonly id: string;
      readonly type: "CONNECTION_ESTABLISHED";
      readonly data: Record<string, never>;
      readonly createdAt: string;
    }
  | {
      readonly id: string;
      readonly type: "HEARTBEAT";
      readonly data: Record<string, never>;
      readonly createdAt: string;
    }
  | {
      readonly id: string;
      readonly type: "SUBSCRIPTION_UPDATED";
      readonly data: {
        customerSubscriptionId: string;
        customerId: string;
        productId: string;
        paymentStatus:
          | "success"
          | "action_required"
          | "failed"
          | "subscription_renewed";
      };
      readonly createdAt: string;
    };
```

### Advanced Event Configuration

Configure reconnection and filtering behavior:

```javascript
async function main() {
  const client = new SnapPay();
  client.events({ reconnectInterval: 5, maxReconnectAttempts: 10 });
  for await (const event of client.streamEvents({}, false)) {
    console.log(`Event: ${event.type}`);
  }
}
```

## Error Handling

The SDK provides comprehensive error handling with typed exceptions:

```javascript
import {
  SnapPay,
  SnapPayError,
  AuthenticationError,
  ValidationError,
  RateLimitError,
  NotFoundError,
} from "@snappay/sdk";

async function comprehensiveErrorHandling() {
  const client = new SnapPay();

  try {
    const customer = await client.customers.get("cus_123", "test@example.com");
  } catch (error) {
    if (error instanceof AuthenticationError) {
      console.log(`Invalid API key: ${error.message}`);
    } else if (error instanceof ValidationError) {
      console.log(`Invalid parameters: ${error.message}`);
    } else if (error instanceof RateLimitError) {
      console.log(`Rate limit exceeded: ${error.message}`);
    } else if (error instanceof NotFoundError) {
      console.log(`Resource not found: ${error.message}`);
    } else if (error instanceof SnapPayError) {
      console.log(`General SnapPay error: ${error.message}`);
    } else {
      console.log(`Unexpected error: ${error.message}`);
    }
  }
}

comprehensiveErrorHandling().catch(console.error);
```

### Exception Hierarchy

```javascript
SnapPayError                    // Base exception
â”œâ”€â”€ AuthenticationError          // Invalid API key or authentication
â”œâ”€â”€ ValidationError              // Invalid parameters or request data
â”œâ”€â”€ RateLimitError              // API rate limit exceeded
â”œâ”€â”€ NotFoundError               // Resource not found
â””â”€â”€ ServerError                 // Server-side errors (5xx responses)
```

## Complete Integration Example

Here's a comprehensive example showing all major SDK features:

```javascript
import { SnapPay, Provider } from "@snappay/sdk";

async function main() {
  const client = new SnapPay();

  try {
    // 1. Customer Management
    const customerRes = await client.customers.get(
      "customer_123",
      "customer@example.com",
      "John Doe"
    );
    const customer = customerRes.ok
      ? customerRes.data
      : (() => {
          throw customerRes.error;
        })();
    console.log(`Customer ID: ${customer.cus_id}`);

    // 2. Create Checkout Session
    const checkout = await client.checkout.createSession(
      customer.cus_id,
      "premium-plan",
      "https://yourapp.com/success",
      "https://yourapp.com/cancel",
      null,
      Provider.STRIPE
    );
    console.log(`Checkout URL: ${checkout.url}`);

    // 3. Check Access (after customer completes purchase)
    const accessResult = await client.access.check(
      customer.cus_id,
      "premium-features"
    );

    if (accessResult.ok && accessResult.data.hasAccess) {
      console.log("Customer has access!");

      // 4. Track Feature Usage
      await client.usage.track(
        customer.cus_id,
        "api-calls",
        1,
        "unique-operation-456"
      );

      // 5. Get Usage Statistics
      const usageRes = await client.usage.get(customer.cus_id, "api-calls");
      if (usageRes.ok && usageRes.data.length) {
        const u = usageRes.data[0];
        console.log(`API calls used: ${u.totalUsage}`);
        if (u.remaining != null) console.log(`Remaining: ${u.remaining}`);
      }
    } else {
      console.log("Customer needs to upgrade for access");
    }
  } catch (error) {
    console.error(`Error: ${error.message}`);
  }
}

async function withRealTimeEvents() {
  // Example with real-time event handling
  const client = new SnapPay();

  // Set up event handlers
  // ...

  // Start listening for events
  await client.startEvents();

  // Your main application logic here
  // Events will be processed in the background
  await new Promise((resolve) => setTimeout(resolve, 60000)); // Run for 1 minute

  // Stop events gracefully
  await client.stopEvents();
}

// Run main integration example
main().catch(console.error);

// Or run with events
// withRealTimeEvents().catch(console.error);
```

This completes the SnapPay JavaScript SDK documentation. The SDK provides a powerful, modern interface for all your payment and subscription management needs with JavaScript and Node.js applications.
