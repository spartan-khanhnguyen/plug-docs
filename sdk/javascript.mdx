---
title: JavaScript SDK
description: Complete guide for integrating SnapPay with JavaScript/Node.js applications using modern async patterns
---

## Overview

The SnapPay JavaScript SDK provides a comprehensive interface for integrating payment processing, subscription management, and real-time event streaming into your JavaScript/Node.js applications. Built with modern async/await patterns and robust error handling, it offers seamless integration with SnapPay's complete platform.

**Requirements:** Node.js 18+

### Key Features

- **Modern async/await design** with fetch API for optimal performance
- **Comprehensive error handling** with typed error responses
- **Real-time event streaming** via Server-Sent Events (SSE)
- **Service-based architecture** for organized functionality
- **Automatic retry logic** and error handling
- **Environment-based configuration**
- **TypeScript support** with full type definitions

## Installation

```bash
npm install @snappay/sdk
```

## Configuration & Initialization

The SDK is configured through environment variables and the client's constructor. All operations require proper authentication and should use async/await patterns for optimal resource management.

### API Key Authentication

Authentication is handled via an API key that must start with `pk_test_` (for testing) or `pk_live_` (for production). Configure your API key in one of these ways:

**Environment Variable (Recommended):**
```bash
export PLUGNPAY_API_KEY="pk_test_xxxxxxxxxx"
```

**Direct Configuration:**
```javascript
import { SnapPay } from '@snappay/sdk';

// Using environment variable (recommended)
const client = new SnapPay();

// Using direct API key
const clientWithKey = new SnapPay({
  apiKey: "pk_test_xxxxxxxxxx"
});
```

### Advanced Configuration

```javascript
import { SnapPay } from '@snappay/sdk';

const client = new SnapPay({
  apiKey: "pk_test_xxxxxxxxxx",
  baseUrl: "https://api.snappay.dev",  // Custom base URL
  timeout: 30000,  // Request timeout in milliseconds
});
```

## Core Methods

All methods are async functions that return promises and must be called with `await`. The SDK uses a service-based architecture where methods are organized into logical groups: `customers`, `checkout`, `access`, and `usage`.

### Customer Management

#### getCustomer

Retrieves or creates a customer record (upsert logic).

```javascript
const customer = await client.getCustomer({
  cusId: "cus_123",
  email: "user@example.com",
  name: "John Doe"  // Optional
});
console.log(`Customer ID: ${customer.customer_id}`);
```

**Parameters:**
- `cusId` (string): Customer identifier
- `email` (string, optional): Customer email address
- `name` (string, optional): Customer full name

**Returns:** `Customer` object with:
- `customer_id` (string): SnapPay customer ID
- `email` (string): Customer email
- `name` (string): Customer name
- `status` (string): Customer account status
- `env` (string): Environment (test/live)

### Checkout Sessions

#### createCheckoutSession

Creates a payment checkout session URL for customer purchases.

```javascript
import { Provider } from '@snappay/sdk';

const session = await client.createCheckoutSession({
  customer_id: "cus_123",
  product_id: "premium-plan",
  success_url: "https://yourapp.com/success",
  cancel_url: "https://yourapp.com/cancel",  // Optional
  provider: Provider.STRIPE,  // Default: STRIPE
  // Additional checkout parameters
  metadata: { order_id: "ord_456" }
});
console.log(`Checkout URL: ${session.url}`);
```

**Parameters:**
- `customer_id` (string): SnapPay customer ID
- `product_id` (string): Product ID from your SnapPay dashboard
- `success_url` (string): URL to redirect after successful payment
- `cancel_url` (string, optional): URL to redirect on cancellation
- `provider` (Provider): Payment provider (defaults to STRIPE)
- Additional checkout session parameters

**Returns:** `CheckoutSession` object with:
- `session_id` (string): Unique session identifier
- `url` (string): Checkout URL for customer
- `expires_at` (string): Session expiration timestamp

### Access Control

#### checkAccess

Checks if a customer has access to a specific feature based on their subscription and usage limits.

```javascript
const access = await client.checkAccess({
  customer_id: "cus_123",
  feature_id: "premium-features"
});

if (access.has_access) {
  const remaining = access.usage_remaining;
  if (remaining !== null) {
    console.log(`Access granted! Remaining usage: ${remaining}`);
  } else {
    console.log("Access granted with unlimited usage!");
  }
} else {
  console.log("Access denied. Upgrade required.");
}
```

**Parameters:**
- `customer_id` (string): SnapPay customer ID
- `feature_id` (string): Feature identifier

**Returns:** `AccessCheck` object with:
- `has_access` (boolean): Whether customer has access
- `feature_id` (string): Feature being checked
- `customer_id` (string): Customer being checked
- `usage_remaining` (number | null): Remaining usage units
- `usage_total` (number | null): Total usage so far
- `usage_limit` (number | null): Maximum usage allowed
- `reset_date` (string | null): When usage resets
- `subscription_status` (string | null): Current subscription status
- `expires_at` (string | null): Access expiration timestamp

### Usage Tracking

#### trackUsage

Reports usage for a metered feature. This action is idempotent to prevent duplicate tracking.

```javascript
const result = await client.trackUsage({
  customer_id: "cus_123",
  feature_id: "ai-messages",
  usage: 1,  // or 1.5 for fractional usage
  idempotency_key: "unique-operation-123"  // Optional
});
console.log(`Usage tracked successfully: ${result.success}`);
```

**Parameters:**
- `customer_id` (string): SnapPay customer ID
- `feature_id` (string): Feature identifier for usage tracking
- `usage` (number): Usage amount to track
- `idempotency_key` (string, optional): Prevents duplicate tracking

**Returns:** `TrackUsageResponse` object with tracking confirmation details.

#### getUsage

Retrieves current usage details for a customer's feature.

```javascript
const usage = await client.getUsage({
  customer_id: "cus_123",
  feature_id: "ai-messages"
});
console.log(`Total usage: ${usage.total_usage}`);
console.log(`Remaining: ${usage.remaining}`);
console.log(`Limit: ${usage.limit}`);
```

**Parameters:**
- `customer_id` (string): SnapPay customer ID
- `feature_id` (string): Feature identifier

**Returns:** `GetUsageResponse` object with current usage and limits.

## Real-time Event Handling

**Say goodbye to webhook hell!** SnapPay eliminates the complexity of managing payment webhooks by processing all provider webhooks (Stripe, PayPal, etc.) internally and delivering clean, structured events directly to your application via Server-Sent Events (SSE).

### üö´ What You DON'T Need:
- **No webhook endpoints** to create and maintain
- **No webhook signature verification**
- **No webhook retry logic** or failure handling
- **No webhook security concerns**
- **No debugging webhook delivery issues**

### ‚úÖ What You GET:
- **Real-time events** delivered instantly to your application
- **Guaranteed delivery** with automatic reconnection
- **Clean, structured data** - no raw webhook payloads
- **Multiple consumption patterns** to fit your architecture
- **Type-safe event objects** with full IDE support

### Stream Events (Async Iterator)

Simply iterate over events as they arrive - SnapPay handles all the webhook complexity behind the scenes:

```javascript
import { SnapPay } from '@snappay/sdk';

async function main() {
  const client = new SnapPay();
  console.log("Listening for payment events (no webhooks needed!)...");

  // SnapPay processes Stripe/PayPal webhooks and sends you clean events
  for await (const event of client.streamEvents()) {
    console.log(`Event: ${event.webhook_event_type}`);
    console.log(`Customer: ${event.customer_id}`);

    // Handle purchase completion instantly
    if (event.webhook_event_type === "subscription.created") {
      const customer_id = event.customer_id;
      console.log(`üéâ New subscriber: ${customer_id}`);
      // Provision access immediately - no webhook delays!
    } else if (event.webhook_event_type === "payment_intent.succeeded") {
      console.log(`üí∞ Payment received for ${event.customer_id}`);
      // Update user account, send receipt, etc.
    }
  }
}

main().catch(console.error);
```

### Event Handlers

Set up handlers for specific payment events - SnapPay converts complex webhook payloads into simple, actionable events:

```javascript
import { SnapPay } from '@snappay/sdk';

function handleNewSubscription(event) {
  // Called when customer completes subscription purchase
  const customer_id = event.customer_id;
  console.log(`üéâ New subscriber: ${customer_id}`);

  // Immediately provision access - no webhook complexity!
  // SnapPay already verified the payment and processed the webhook
  provisionPremiumAccess(customer_id);
  sendWelcomeEmail(customer_id);
}

function handleSuccessfulPayment(event) {
  // Called when payment is confirmed by payment provider
  const customer_id = event.customer_id;
  const payment_data = event.event_data.payment_intent || {};
  const amount = payment_data.amount || 0;

  console.log(`üí∞ Payment confirmed: $${amount/100} from ${customer_id}`);
  // Update billing, send receipt, extend service, etc.
}

function handleFailedPayment(event) {
  // Called when payment fails
  const customer_id = event.customer_id;
  console.log(`‚ùå Payment failed for ${customer_id}`);
  // Notify customer, pause service, handle dunning, etc.
}

async function main() {
  const client = new SnapPay();

  // No webhook setup needed - just register your handlers
  client.on("subscription.created", handleNewSubscription);
  client.on("payment_intent.succeeded", handleSuccessfulPayment);
  client.on("payment_intent.payment_failed", handleFailedPayment);

  // Start receiving events (SnapPay handles all webhook processing)
  await client.startEvents();

  console.log("üöÄ Listening for payment events - webhook-free!");
  await new Promise(resolve => setTimeout(resolve, 3600000)); // Your app runs normally
}

main().catch(console.error);
```

### Event Structure

SnapPay transforms raw webhook payloads from payment providers into clean, structured `SSEEvent` objects:

```javascript
// What you receive (clean, structured)
const event = {
  event_id: "evt_123456",                    // Unique event identifier
  webhook_event_type: "subscription.created", // Standardized event type
  customer_id: "cus_123",                    // Your customer ID
  event_data: {                             // Relevant data only
    subscription: { id: "sub_456", status: "active" },
    customer: { email: "user@example.com" }
  },
  created_at: "2024-01-01T10:00:00Z"        // Event timestamp
};

// vs. what you'd get with raw Stripe webhooks:
// {
//   "id": "evt_stripe_raw_123",
//   "object": "event",
//   "api_version": "2020-08-27",
//   "created": 1609459200,
//   "data": {
//     "object": {
//       "id": "sub_stripe_456",
//       "object": "subscription",
//       ... 50+ more fields
//     }
//   },
//   "type": "customer.subscription.created",
//   ... many more fields
// }
```

### Advanced Event Configuration

Configure reconnection and filtering behavior:

```javascript
async function main() {
  const client = new SnapPay();

  // Configure SSE client
  const sseClient = client.events({
    reconnect_interval: 5,  // Seconds between reconnection attempts
    max_reconnect_attempts: 10  // Maximum reconnection attempts
  });

  // Stream with configuration
  for await (const event of client.streamEvents({
    reconnect_interval: 5,
    max_reconnect_attempts: 10,
    include_system_events: false  // Exclude heartbeat events
  })) {
    console.log(`Event: ${event.webhook_event_type}`);
  }
}
```

### Production-Ready Event Handling

Here's a complete example showing how SnapPay eliminates webhook complexity for a SaaS application:

```javascript
import { SnapPay } from '@snappay/sdk';

// Configure logging
const logger = console;

function handleSubscriptionCreated(event) {
  // New customer subscribed - provision access immediately
  const customer_id = event.customer_id;
  const subscription_data = event.event_data.subscription || {};
  const plan_id = subscription_data.plan_id;

  logger.info(`üéâ New subscriber: ${customer_id} on plan ${plan_id}`);

  // Instant provisioning - no webhook delays or failures
  try {
    enablePremiumFeatures(customer_id, plan_id);
    sendWelcomeEmail(customer_id);
    updateUserDashboard(customer_id, "premium");
    logger.info(`‚úÖ Provisioned access for ${customer_id}`);
  } catch (e) {
    logger.error(`‚ùå Failed to provision ${customer_id}: ${e}`);
  }
}

function handlePaymentSucceeded(event) {
  // Payment confirmed - extend service
  const customer_id = event.customer_id;
  const invoice_data = event.event_data.invoice || {};
  const amount = invoice_data.amount_paid || 0;

  logger.info(`üí∞ Payment received: $${amount/100} from ${customer_id}`);

  // Process payment instantly
  extendServicePeriod(customer_id);
  sendReceipt(customer_id, amount);
  updateBillingHistory(customer_id, amount);
}

function handleSubscriptionCancelled(event) {
  // Subscription cancelled - manage gracefully
  const customer_id = event.customer_id;

  logger.info(`üìã Subscription cancelled for ${customer_id}`);

  // Handle cancellation
  scheduleAccessRevocation(customer_id);  // Grace period
  sendCancellationEmail(customer_id);
  triggerWinBackCampaign(customer_id);
}

async function runPaymentProcessor() {
  // Main application with webhook-free payment processing
  const client = new SnapPay();
  logger.info("üöÄ Starting payment processor (no webhooks needed)");

  // Register all payment event handlers
  client.on("subscription.created", handleSubscriptionCreated);
  client.on("subscription.updated", (e) => logger.info(`Plan updated: ${e.customer_id}`));
  client.on("subscription.deleted", handleSubscriptionCancelled);
  client.on("invoice.payment.succeeded", handlePaymentSucceeded);
  client.on("invoice.payment.failed", (e) => handlePaymentFailure(e.customer_id));

  // Start processing events - SnapPay handles all webhook complexity
  await client.startEvents();

  logger.info("‚ú® Payment processor running - webhook-free architecture!");

  // Your application continues running normally
  // Events are processed in real-time as payments happen
  try {
    while (true) {
      await new Promise(resolve => setTimeout(resolve, 60000));  // Keep alive
      logger.debug("Payment processor healthy");
    }
  } catch (error) {
    logger.info("Shutting down payment processor...");
  } finally {
    await client.stopEvents();
  }
}

function handlePaymentFailure(customer_id) {
  // Handle failed payments
  logger.warn(`‚ùå Payment failed for ${customer_id}`);
  // Retry logic, dunning management, etc.
}

// Helper functions (implement these for your app)
function enablePremiumFeatures(customer_id, plan_id) {}
function sendWelcomeEmail(customer_id) {}
function updateUserDashboard(customer_id, tier) {}
function extendServicePeriod(customer_id) {}
function sendReceipt(customer_id, amount) {}
function updateBillingHistory(customer_id, amount) {}
function scheduleAccessRevocation(customer_id) {}
function sendCancellationEmail(customer_id) {}
function triggerWinBackCampaign(customer_id) {}

// No webhook server needed - just run your payment processor!
runPaymentProcessor().catch(console.error);
```

**Key Benefits Demonstrated:**
- ‚úÖ **Zero webhook infrastructure** - no endpoints, no servers, no security concerns
- ‚úÖ **Instant event processing** - no webhook delivery delays or failures
- ‚úÖ **Simplified error handling** - no webhook verification or retry logic needed
- ‚úÖ **Clean separation of concerns** - focus on business logic, not webhook plumbing

## Error Handling

The SDK provides comprehensive error handling with typed exceptions:

```javascript
import {
  SnapPay, SnapPayError, AuthenticationError,
  ValidationError, RateLimitError, NotFoundError
} from '@snappay/sdk';

async function comprehensiveErrorHandling() {
  const client = new SnapPay();

  try {
    const customer = await client.getCustomer({
      cusId: "cus_123",
      email: "test@example.com"
    });
  } catch (error) {
    if (error instanceof AuthenticationError) {
      console.log(`Invalid API key: ${error.message}`);
    } else if (error instanceof ValidationError) {
      console.log(`Invalid parameters: ${error.message}`);
    } else if (error instanceof RateLimitError) {
      console.log(`Rate limit exceeded: ${error.message}`);
    } else if (error instanceof NotFoundError) {
      console.log(`Resource not found: ${error.message}`);
    } else if (error instanceof SnapPayError) {
      console.log(`General SnapPay error: ${error.message}`);
    } else {
      console.log(`Unexpected error: ${error.message}`);
    }
  }
}

comprehensiveErrorHandling().catch(console.error);
```

### Exception Hierarchy

```javascript
SnapPayError                    // Base exception
‚îú‚îÄ‚îÄ AuthenticationError          // Invalid API key or authentication
‚îú‚îÄ‚îÄ ValidationError              // Invalid parameters or request data
‚îú‚îÄ‚îÄ RateLimitError              // API rate limit exceeded
‚îú‚îÄ‚îÄ NotFoundError               // Resource not found
‚îî‚îÄ‚îÄ ServerError                 // Server-side errors (5xx responses)
```

## Complete Integration Example

Here's a comprehensive example showing all major SDK features:

```javascript
import { SnapPay, Provider } from '@snappay/sdk';

async function main() {
  const client = new SnapPay();

  try {
    // 1. Customer Management
    const customer = await client.getCustomer({
      cusId: "customer_123",
      email: "customer@example.com",
      name: "John Doe"
    });
    console.log(`Customer ID: ${customer.customer_id}`);

    // 2. Create Checkout Session
    const checkout = await client.createCheckoutSession({
      customer_id: customer.customer_id,
      product_id: "premium-plan",
      success_url: "https://yourapp.com/success",
      cancel_url: "https://yourapp.com/cancel",
      provider: Provider.STRIPE
    });
    console.log(`Checkout URL: ${checkout.url}`);

    // 3. Check Access (after customer completes purchase)
    const access = await client.checkAccess({
      customer_id: customer.customer_id,
      feature_id: "premium-features"
    });

    if (access.has_access) {
      console.log("Customer has access!");

      // 4. Track Feature Usage
      await client.trackUsage({
        customer_id: customer.customer_id,
        feature_id: "api-calls",
        usage: 1,
        idempotency_key: "unique-operation-456"
      });

      // 5. Get Usage Statistics
      const usage = await client.getUsage({
        customer_id: customer.customer_id,
        feature_id: "api-calls"
      });
      console.log(`API calls used: ${usage.total_usage}`);
      if (usage.usage_remaining) {
        console.log(`Remaining: ${usage.usage_remaining}`);
      }
    } else {
      console.log("Customer needs to upgrade for access");
    }
  } catch (error) {
    console.error(`Error: ${error.message}`);
  }
}

async function withRealTimeEvents() {
  // Example with real-time event handling
  const client = new SnapPay();

  // Set up event handlers
  client.on("subscription.created",
    (e) => console.log(`New subscription for ${e.customer_id}`)
  );
  client.on("payment_intent.succeeded",
    (e) => console.log(`Payment successful for ${e.customer_id}`)
  );

  // Start listening for events
  await client.startEvents();

  // Your main application logic here
  // Events will be processed in the background
  await new Promise(resolve => setTimeout(resolve, 60000)); // Run for 1 minute

  // Stop events gracefully
  await client.stopEvents();
}

// Run main integration example
main().catch(console.error);

// Or run with events
// withRealTimeEvents().catch(console.error);
```

This completes the SnapPay JavaScript SDK documentation. The SDK provides a powerful, modern interface for all your payment and subscription management needs with JavaScript and Node.js applications.