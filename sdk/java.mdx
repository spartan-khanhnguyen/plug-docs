---
title: Java SDK
description: Complete guide for integrating PlugnPay with Java applications using modern asynchronous patterns and reactive programming
---

## Overview

The PlugnPay Java SDK provides a comprehensive, enterprise-grade interface for integrating payment processing, subscription management, and real-time event streaming into your Java applications. Built with modern Java patterns including CompletableFuture for asynchronous operations, reactive streams for event handling, and comprehensive type safety, it offers seamless integration with PlugnPay's complete platform.

**Requirements:** Java 11+ / Maven or Gradle

### Key Features

- **Modern async design** with CompletableFuture and reactive patterns for optimal performance
- **Enterprise-grade reliability** with connection pooling and automatic retry mechanisms
- **Real-time event streaming** via Server-Sent Events (SSE) with reactive programming support
- **Full type safety** with immutable POJOs and builder patterns
- **Thread-safe client** for concurrent usage across your application
- **Comprehensive error handling** with typed exceptions and detailed error contexts
- **Framework integrations** for Spring Boot, Quarkus, and Micronaut
- **Environment-based configuration** with flexible setup options

## Installation

### Maven

```xml
<dependency>
    <groupId>dev.plugnpay</groupId>
    <artifactId>plugnpay-sdk</artifactId>
    <version>1.0.0</version>
</dependency>
```

### Gradle

```groovy
dependencies {
    implementation 'dev.plugnpay:plugnpay-sdk:1.0.0'
}
```

### Gradle (Kotlin DSL)

```kotlin
dependencies {
    implementation("dev.plugnpay:plugnpay-sdk:1.0.0")
}
```

## Configuration & Initialization

The SDK client is configured via a primary constructor that accepts a configuration object. All operations return CompletableFuture for asynchronous execution and proper resource management.

### API Key Authentication

Authentication is handled via an API key that must start with `pk_test_` (for testing) or `pk_live_` (for production). Configure your API key in one of these ways:


**Direct Configuration:**
```java
import dev.plugnpay.sdk.PlugnPayClient;

var config = new PlugnPayClient.Config.Builder()
    .apiKey("pk_test_xxxxxxxxxx")
    .build();

PlugnPayClient client = new PlugnPayClient(config)
```

### Advanced Configuration

```java
import dev.plugnpay.sdk.PlugnPayClient;

var config = new PlugnPayClient.Config.Builder()
    .apiKey("pk_test_xxxxxxxxxx")
    .connectTimeoutSeconds(10)
    .readTimeoutSeconds(10)
    .writeTimeoutSeconds(10)
    .timeoutSeconds(10)
    .build();

PlugnPayClient client = new PlugnPayClient(config);
```

## Core Methods

All methods return CompletableFuture objects for asynchronous execution and can be chained with standard reactive patterns. They throw typed PlugnPayException subclasses on failure. Models are defined using immutable POJOs with builder patterns.

### Customer Management

#### getCustomer

Retrieves or creates a customer record (upsert logic).

```java
var customer = client.getCustomers().getCustomer("user_123", "john@example.com", "John Doe");
System.out.println("Customer ID: " + customer.getId());
```

**Parameters:**
- `id` (String): Customer identifier
- `email` (String, optional): Customer email address
- `name` (String, optional): Customer full name

**Returns:** 
```java
public class Customer {    
    public String getId()
    public String getEmail()
    public String getName()
    public String getStatus()
}
```

### Checkout Sessions

#### createCheckoutSession

Creates a payment checkout session URL for customer purchases.

```java
var checkout = client.getCheckout().createCheckoutSession(
        customer.getId(),
        "beta-free-1",
        "https://example.com/success",
        "https://example.com/cancel",
        "stripe"
    );

System.out.println("Checkout URL: " + checkout.getUrl());
```

**Parameters:**
- `customerId` (String): PlugnPay customer ID
- `productId` (String): Product ID from your PlugnPay dashboard
- `successUrl` (String): URL to redirect after successful payment
- `cancelUrl` (String, optional): URL to redirect on cancellation
- `provider` (Provider): Payment provider (defaults `stripe`)
- `metadata` (Map&lt;String, String&gt;): Additional checkout parameters

**Returns:**
```java
public class CheckoutSession {    
    public String getUrl()
    public String getSessionId()
    public String getExpiresAt()
}
```

### Access Control

#### checkAccess

Checks if a customer has access to a specific feature based on their subscription and usage limits.

```java
var accessResult = client.getAccess().checkAccess(customer.getId(), "feature-xxx");

System.out.println("Customer Id: " + accessResult.getCustomerId());
System.out.println("Has access: " + accessResult.getHasAccess());

```

**Parameters:**
- `customerId` (String): PlugnPay customer ID
- `featureId` (String): Feature identifier

**Returns:**
```java
public class AccessResult {   
    public boolean isHasAccess()
    public String getFeatureId()
    public String getCustomerId()
    public int getUsed()
    public int getLimit()
    public String getResetDate()
    public String getSubscriptionStatus()
}
```

### Usage Tracking

#### trackUsage

Reports usage for a metered feature. This action is idempotent to prevent duplicate tracking.

```java
var tracked = client.getUsage().trackUsage(customer.getId(), "feature-xxxx", 1, null);

System.out.println("Added this time: " + tracked.getAdded());
System.out.println("Total used: " + tracked.getUsed());
System.out.println("Track idempotency key: " + tracked.getIdempotencyKey());
```

**Parameters:**
- `customerId` (String): PlugnPay customer ID
- `featureId` (String): Feature identifier for usage tracking
- `usage` (Double): Usage amount to track
- `idempotencyKey` (String, optional): Prevents duplicate tracking

**Returns:**
```java
public class TrackUsage {
    public String getCustomerId()
    public String getFeatureId()
    public int getAdded()
    public int getUsed()
    public String getTimestamp()
    public String getIdempotencyKey()
}
```

#### getUsage

Retrieves current usage details for a customer's feature.

```java
var usage = client.getUsage().getUsage(customer.getId(), "feature-xxxx");


System.out.println("Used: " + usage.getUsed());
System.out.println("Limit: " + usage.getLimit());
```

**Parameters:**
- `customerId` (String): PlugnPay customer ID
- `featureId` (String): Feature identifier

**Returns:**
```java
public class UsageStats {    
    public int getLimit()
    public int getUsed()
}
```

## Real-time Event Handling

**Say goodbye to webhook hell!** PlugnPay eliminates the complexity of managing payment webhooks by processing all provider webhooks (Stripe, PayPal, etc.) internally and delivering clean, structured events directly to your application via Server-Sent Events (SSE) using reactive patterns.

### ðŸš« What You DON'T Need:
- **No webhook endpoints** to create and maintain
- **No webhook signature verification**
- **No webhook retry logic** or failure handling
- **No webhook security concerns**
- **No debugging webhook delivery issues**

### âœ… What You GET:
- **Real-time events** delivered instantly via reactive streams
- **Guaranteed delivery** with automatic reconnection
- **Clean, structured data** - no raw webhook payloads
- **Reactive programming** perfect for Java's async ecosystem
- **Type-safe event objects** with comprehensive error handling

### Reactive Event Streaming

Simply subscribe to events as they arrive - PlugnPay handles all the webhook complexity behind the scenes:

```java
Flow.Publisher<SseEvent> publisher = client.getSse().subscribe(null);

publisher.subscribe(new Flow.Subscriber<>() {
    private Flow.Subscription subscription;

    @Override
    public void onSubscribe(Flow.Subscription subscription) {
        this.subscription = subscription;
        subscription.request(1);
    }

    @Override
    public void onNext(SseEvent event) {
        System.out.println("Java => Event: " + event.getType() +
                " | Customer: " + event.getId());
        subscription.request(1);
    }

    @Override
    public void onError(Throwable throwable) {
        System.err.println("Java => Error: " + throwable.getMessage());
    }

    @Override
    public void onComplete() {
        System.out.println("Java => Stream completed");
    }
});
```

### Event Structure

PlugnPay transforms raw webhook payloads from payment providers into clean, structured event objects:

```java
// Event represents a single message from the event stream
public class SseEvent {
    public String getId()
    public String getType()
    public Object getData()
    public String getCreatedAt()
}
```

### Exception Hierarchy

The SDK provides comprehensive error handling with typed exceptions and detailed error contexts:

```java
public class PlugnPayError extends RuntimeException {}

public class AuthenticationError extends PlugnPayError {}

public class ValidationError extends PlugnPayError {}

public class NotFoundError extends PlugnPayError {}

public class ConflictError extends PlugnPayError {}

public class RateLimitError extends PlugnPayError {}

public class ServerError extends PlugnPayError {}
```


## Complete Integration Example

Here's a comprehensive example showing all major SDK features:

```java
package org.example;

import dev.plugnpay.sdk.PlugnPayClient;
import dev.plugnpay.sdk.SseEvent;

import java.util.concurrent.Flow;

public class SseBasicJava {
    public static void main(String[] args) {
        var config = new PlugnPayClient.Config.Builder()
                .apiKey("pk_test_xxxxxxxxxx")
                .build();

        try (PlugnPayClient client = new PlugnPayClient(config)) {

            Flow.Publisher<SseEvent> publisher = client.getSse().subscribe(null);

            publisher.subscribe(new Flow.Subscriber<>() {
                private Flow.Subscription subscription;

                @Override
                public void onSubscribe(Flow.Subscription subscription) {
                    this.subscription = subscription;
                    subscription.request(1);
                }

                @Override
                public void onNext(SseEvent event) {
                    System.out.println("Java => Event: " + event.getType() +
                            " | Customer: " + event.getId());
                    subscription.request(1);
                }

                @Override
                public void onError(Throwable throwable) {
                    System.err.println("Java => Error: " + throwable.getMessage());
                }

                @Override
                public void onComplete() {
                    System.out.println("Java => Stream completed");
                }
            });

            var customer = client.getCustomers().getCustomer("user_123", "john@example.com", "John Doe");
            var checkout = client.getCheckout().createCheckoutSession(
                    customer.getId(),
                    "beta-free-1",
                    "https://example.com/success",
                    "https://example.com/cancel",
                    "stripe"
            );

            System.out.println("Checkout URL: " + checkout.getUrl());

            var tracked = client.getUsage().trackUsage(customer.getId(), "sand-ft-messages", 1, null);

            System.out.println("Added this time: " + tracked.getAdded());
            System.out.println("Total used: " + tracked.getUsed());
            System.out.println("Track idempotency key: " + tracked.getIdempotencyKey());

            var usage = client.getUsage().getUsage(customer.getId(), "sand-ft-messages");


            System.out.println("Used: " + usage.getUsed());
            System.out.println("Limit: " + usage.getLimit());
        }
    }
}
```

This completes the comprehensive PlugnPay Java SDK documentation. The SDK provides enterprise-grade patterns with CompletableFuture, reactive programming, and comprehensive type safety for all your payment and subscription management needs in Java applications.