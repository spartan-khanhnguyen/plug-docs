---
title: Go SDK
description: Complete guide for integrating PlugnPay with Go applications using idiomatic Go patterns and concurrency
---

## Overview

The PlugnPay Go SDK provides a comprehensive, idiomatic interface for integrating payment processing, subscription management, and real-time event streaming into your Go applications. Built with modern Go patterns including context support, channel-based concurrency, and explicit error handling, it offers seamless integration with PlugnPay's complete platform.

**Requirements:** Go 1.22.6+

### Key Features

- **Customer Management**: Create, retrieve, and manage customer accounts
- **Access Control**: Check feature access and permissions
- **Checkout Sessions**: Create payment checkout sessions
- **Usage Tracking**: Track and monitor API usage
- **Real-time Events**: Server-Sent Events (SSE) for real-time notifications
- **Comprehensive Error Handling**: Detailed error responses and validation
- **Idiomatic Go design** with context.Context support for cancellation and timeouts
- **Channel-based concurrency** for optimal performance and real-time event handling
- **Explicit error handling** following Go conventions
- **Full type safety** with struct definitions and interface contracts
- **Goroutine-safe client** for concurrent usage across your application

## Installation

```bash
go get github.com/plugnpay/plugnpay-sdk-go
```

Add to your `go.mod`:
```go
module your-app

go 1.22.6

require (
    github.com/plugnpay/plugnpay-sdk-go v1.0.0
)
```

## Configuration & Initialization

The SDK client is configured via a constructor function that accepts an optional configuration struct. All operations support context.Context for proper timeout and cancellation handling.

### API Key Authentication

Authentication is handled via an API key that must start with `pk_test_` (for testing) or `pk_live_` (for production). Configure your API key in one of these ways:

**Environment Variable (Recommended):**
```bash
export PLUGNPAY_API_KEY="pk_test_xxxxxxxxxx"
```

**Direct Configuration:**
```go
package main

import (
    "context"
    "log"
    "github.com/plugnpay/plugnpay-sdk-go"
    "github.com/plugnpay/plugnpay-sdk-go/services"
)

func main() {
    // Using environment variable (recommended)
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }

    // Using direct API key
    client, err := plugnpay.NewClient(&services.Config{
        APIKey: "pk_test_xxxxxxxxxx",
    })
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }
}
```

### Advanced Configuration

```go
import "time"

config := &services.Config{
    APIKey:     "pk_test_xxxxxxxxxx",
    UserAgent:  "MyApp/1.0.0",               // Custom user agent
    HTTPClient: &http.Client{                // Custom HTTP client
        Timeout: 30 * time.Second,
    },
    SSE: &services.SSEConfig{               // Optional: SSE configuration
        ReconnectInterval:     5 * time.Second,
        MaxReconnectAttempts:  5,
        HeartbeatInterval:     30 * time.Second,
        ConnectionTimeout:     60 * time.Second,
    },
}

client, err := plugnpay.NewClient(config)
if err != nil {
    log.Fatalf("Failed to create client: %v", err)
}
```

## Core Methods

All methods accept a `context.Context` as the first parameter and return a result struct pointer and an error, following standard Go patterns. The client is safe for concurrent use across multiple goroutines.

### Customer Management

#### GetCustomer

Retrieves or creates a customer record (upsert logic).

```go
import "github.com/plugnpay/plugnpay-sdk-go/services/customer"

ctx := context.Background()
customer, err := customer.GetCustomer(client, ctx, customer.GetCustomerArgs{
    CusID: "cus_123",
    Email: stringPtr("user@example.com"),
    Name:  stringPtr("John Doe"), // Optional
})
if err != nil {
    log.Fatalf("Failed to get customer: %v", err)
}
fmt.Printf("Customer ID: %s\n", customer.CustomerID)
```

**Parameters:**
- `CusID` (string): Customer identifier
- `Email` (*string): Customer email address (optional)
- `Name` (*string): Customer full name (optional)

**Returns:** `(*Customer, error)`
```go
type Customer struct {
    CustomerID string  `json:"customer_id"` // PlugnPay customer ID
    Email      string  `json:"email"`       // Customer email
    Name       *string `json:"name"`        // Customer name (optional)
    Status     string  `json:"status"`      // Customer account status
    Env        string  `json:"env"`         // Environment (test/live)
    CreatedAt  *string `json:"created_at"`  // Creation timestamp
    UpdatedAt  *string `json:"updated_at"`  // Last update timestamp
}
```

### Checkout Sessions

#### CreateCheckoutSession

Creates a payment checkout session URL for customer purchases.

```go
import "github.com/plugnpay/plugnpay-sdk-go/services/checkout"

ctx := context.Background()
session, err := checkout.CreateCheckoutSession(client, ctx, checkout.CreateCheckoutSessionArgs{
    CustomerID: "cus_123",
    ProductID:  "premium-plan",
    SuccessURL: "https://yourapp.com/success",
    CancelURL:  stringPtr("https://yourapp.com/cancel"), // Optional
    Provider:   checkout.ProviderStripe,                 // Default: ProviderStripe
    Metadata: map[string]string{                         // Optional
        "order_id": "ord_456",
    },
})
if err != nil {
    log.Fatalf("Failed to create checkout session: %v", err)
}
fmt.Printf("Checkout URL: %s\n", session.URL)
```

**Parameters:**
- `CustomerID` (string): PlugnPay customer ID
- `ProductID` (string): Product ID from your PlugnPay dashboard
- `SuccessURL` (string): URL to redirect after successful payment
- `CancelURL` (*string): URL to redirect on cancellation (optional)
- `Provider` (Provider): Payment provider (defaults to ProviderStripe)
- `Metadata` (map[string]string): Additional checkout parameters (optional)

**Returns:** `(*CheckoutSession, error)`
```go
type CheckoutSession struct {
    SessionID string  `json:"session_id"` // Unique session identifier
    URL       string  `json:"url"`        // Checkout URL for customer
    ExpiresAt string  `json:"expires_at"` // Session expiration timestamp
}
```

### Access Control

#### CheckAccess

Checks if a customer has access to a specific feature based on their subscription and usage limits.

```go
import "github.com/plugnpay/plugnpay-sdk-go/services/access"

ctx := context.Background()
access, err := access.CheckAccess(client, ctx, access.CheckAccessArgs{
    CustomerID: "cus_123",
    FeatureID:  "premium-features",
})
if err != nil {
    log.Fatalf("Failed to check access: %v", err)
}

if access.HasAccess {
    if access.UsageRemaining != nil {
        fmt.Printf("Access granted! Remaining usage: %d\n", *access.UsageRemaining)
    } else {
        fmt.Println("Access granted with unlimited usage!")
    }
} else {
    fmt.Println("Access denied. Upgrade required.")
}
```

**Parameters:**
- `CustomerID` (string): PlugnPay customer ID
- `FeatureID` (string): Feature identifier

**Returns:** `(*AccessCheck, error)`
```go
type AccessCheck struct {
    HasAccess          bool    `json:"has_access"`            // Whether customer has access
    FeatureID          string  `json:"feature_id"`            // Feature being checked
    CustomerID         string  `json:"customer_id"`           // Customer being checked
    UsageRemaining     *int64  `json:"usage_remaining"`       // Remaining usage units
    UsageTotal         *int64  `json:"usage_total"`           // Total usage so far
    UsageLimit         *int64  `json:"usage_limit"`           // Maximum usage allowed
    ResetDate          *string `json:"reset_date"`            // When usage resets
    SubscriptionStatus *string `json:"subscription_status"`   // Current subscription status
    ExpiresAt          *string `json:"expires_at"`            // Access expiration timestamp
}
```

### Usage Tracking

#### TrackUsage

Reports usage for a metered feature. This action is idempotent to prevent duplicate tracking.

```go
import "github.com/plugnpay/plugnpay-sdk-go/services/usage"

ctx := context.Background()
result, err := usage.TrackUsage(client, ctx, usage.TrackUsageArgs{
    CustomerID:     "cus_123",
    FeatureID:      "ai-messages",
    Usage:          1,   // or 1.5 for fractional usage
    IdempotencyKey: stringPtr("unique-operation-123"), // Optional
})
if err != nil {
    log.Fatalf("Failed to track usage: %v", err)
}
fmt.Printf("Usage tracked successfully: %t\n", result.Success)
```

**Parameters:**
- `CustomerID` (string): PlugnPay customer ID
- `FeatureID` (string): Feature identifier for usage tracking
- `Usage` (float64): Usage amount to track
- `IdempotencyKey` (*string): Prevents duplicate tracking (optional)

**Returns:** `(*TrackUsageResponse, error)`
```go
type TrackUsageResponse struct {
    Success bool `json:"success"` // Tracking confirmation
}
```

#### GetUsage

Retrieves current usage details for a customer's feature.

```go
ctx := context.Background()
usage, err := usage.GetUsage(client, ctx, usage.GetUsageArgs{
    CustomerID: "cus_123",
    FeatureID:  "ai-messages",
})
if err != nil {
    log.Fatalf("Failed to get usage: %v", err)
}

fmt.Printf("Total usage: %d\n", usage.TotalUsage)
fmt.Printf("Remaining: %s\n", formatUsage(usage.Remaining))
fmt.Printf("Limit: %s\n", formatUsage(usage.Limit))
```

**Parameters:**
- `CustomerID` (string): PlugnPay customer ID
- `FeatureID` (string): Feature identifier

**Returns:** `(*GetUsageResponse, error)`
```go
type GetUsageResponse struct {
    Limit      *int64 `json:"limit"`       // Total limit for period (nil for unlimited)
    TotalUsage int64  `json:"total_usage"` // Total usage in current billing period
    Remaining  *int64 `json:"remaining"`   // Remaining usage (nil if limit is nil)
}
```

## Real-time Event Handling

**Say goodbye to webhook hell!** PlugnPay eliminates the complexity of managing payment webhooks by processing all provider webhooks (Stripe, PayPal, etc.) internally and delivering clean, structured events directly to your application via Server-Sent Events (SSE) using Go channels.

### ðŸš« What You DON'T Need:
- **No webhook endpoints** to create and maintain
- **No webhook signature verification**
- **No webhook retry logic** or failure handling
- **No webhook security concerns**
- **No debugging webhook delivery issues**

### âœ… What You GET:
- **Real-time events** delivered instantly via Go channels
- **Guaranteed delivery** with automatic reconnection
- **Clean, structured data** - no raw webhook payloads
- **Channel-based concurrency** perfect for Go's goroutine model
- **Context-aware** with proper cancellation support

### Channel-Based Event Streaming

Simply receive events from channels as they arrive - PlugnPay handles all the webhook complexity behind the scenes:

```go
package main

import (
    "context"
    "log"
    "os/signal"
    "syscall"
    "time"
    "github.com/plugnpay/plugnpay-sdk-go"
    "github.com/plugnpay/plugnpay-sdk-go/services/sse"
)

func main() {
    // Graceful shutdown context
    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    client, err := plugnpay.NewClient(nil)
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }

    // Register event handlers
    client.OnEvent("subscription.created", handleSubscriptionCreated)
    client.OnEvent("payment_intent.succeeded", handlePaymentSucceeded)
    client.OnEvent("payment_intent.failed", handlePaymentFailed)
    
    log.Println("Listening for payment events (no webhooks needed!)...")

    // Start listening for events
    if err := client.StartEvents(ctx); err != nil {
        log.Fatalf("Failed to start events: %v", err)
    }

    // Also monitor the stream channels for additional debugging
    eventChan, errorChan := client.StreamEvents(ctx)
    
    // Monitor stream channels in a goroutine
    go func() {
        for {
            select {
            case event := <-eventChan:
                if event != nil {
                    // Events are already handled by the registered handlers
                    // This is just for additional monitoring
                }
            case err := <-errorChan:
                if err != nil {
                    log.Printf("âš ï¸  SSE Error: %v", err)
                }
            case <-ctx.Done():
                return
            }
        }
    }()

    log.Println("âœ… SSE connection established and monitoring started!")

    // Keep running until interrupted
    <-ctx.Done()
    log.Println("Shutting down...")
    client.StopEvents()
}

func handleSubscriptionCreated(event *sse.SSEEvent) error {
    log.Printf("ðŸŽ‰ New subscriber: %s", event.CustomerID)
    // Provision access immediately - no webhook delays!
    return nil
}

func handlePaymentSucceeded(event *sse.SSEEvent) error {
    log.Printf("ðŸ’° Payment received for %s", event.CustomerID)
    // Update user account, send receipt, etc.
    return nil
}

func handlePaymentFailed(event *sse.SSEEvent) error {
    log.Printf("âŒ Payment failed for %s", event.CustomerID)
    // Handle payment failure
    return nil
}
```

### Event Structure

PlugnPay transforms raw webhook payloads from payment providers into clean, structured event objects:

```go
// SSEEvent represents a single message from the event stream
type SSEEvent struct {
    EventID           string                 `json:"event_id"`            // Unique event identifier
    EventType         string                 `json:"event_type"`          // Internal event type
    WebhookEventType  string                 `json:"webhook_event_type"`  // Original webhook event type
    CustomerID        string                 `json:"customer_id"`         // Your customer ID
    OrgID             string                 `json:"org_id"`              // Organization ID
    Timestamp         string                 `json:"timestamp"`           // Event timestamp
    EventData         map[string]interface{} `json:"event_data"`          // Event-specific data
}

// Event handler function type
type EventHandler func(event *SSEEvent) error

// Common event types
const (
    EventTypeHeartbeat              = "heartbeat"
    EventTypeConnectionEstablished  = "connection.established"
    EventTypeSubscriptionCreated    = "subscription.created"
    EventTypeSubscriptionUpdated    = "subscription.updated"
    EventTypeSubscriptionDeleted    = "subscription.deleted"
    EventTypePaymentSucceeded       = "payment_intent.succeeded"
    EventTypePaymentFailed          = "payment_intent.failed"
    EventTypeInvoicePaymentSucceeded = "invoice.payment.succeeded"
    EventTypeInvoicePaymentFailed   = "invoice.payment.failed"
    EventTypeCustomerCreated        = "customer.created"
    EventTypeCustomerUpdated        = "customer.updated"
)
```

### Production-Ready Event Handling

Here's a complete example showing how PlugnPay eliminates webhook complexity for a SaaS application:

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "os/signal"
    "sync"
    "syscall"
    "time"
    "github.com/plugnpay/plugnpay-go"
)

type PaymentProcessor struct {
    client *plugnpay.Client
    logger *log.Logger
    wg     sync.WaitGroup
}

func NewPaymentProcessor() (*PaymentProcessor, error) {
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        return nil, err
    }

    return &PaymentProcessor{
        client: client,
        logger: log.Default(),
    }, nil
}

func (p *PaymentProcessor) Start(ctx context.Context) error {
    p.logger.Println("ðŸš€ Starting payment processor (no webhooks needed)")

    eventCh, errCh, err := p.client.ListenForEvents(ctx)
    if err != nil {
        return err
    }

    p.logger.Println("âœ¨ Payment processor running - webhook-free architecture!")

    for {
        select {
        case <-ctx.Done():
            p.logger.Println("Shutting down payment processor...")
            p.wg.Wait() // Wait for all event processing to complete
            return ctx.Err()

        case err := <-errCh:
            p.logger.Printf("âŒ Event stream error: %v", err)
            // Implement exponential backoff retry logic
            time.Sleep(5 * time.Second)
            return err

        case event := <-eventCh:
            // Process events concurrently
            p.wg.Add(1)
            go func(e plugnpay.Event) {
                defer p.wg.Done()
                p.processEvent(e)
            }(event)
        }
    }
}

func (p *PaymentProcessor) processEvent(event plugnpay.Event) {
    p.logger.Printf("Processing event %s: %s", event.EventID, event.EventType)

    switch event.EventType {
    case "subscription.created":
        p.handleSubscriptionCreated(event)
    case "subscription.updated":
        p.handleSubscriptionUpdated(event)
    case "subscription.deleted":
        p.handleSubscriptionCancelled(event)
    case "invoice.payment.succeeded":
        p.handlePaymentSucceeded(event)
    case "invoice.payment.failed":
        p.handlePaymentFailed(event)
    default:
        p.logger.Printf("Unhandled event type: %s", event.EventType)
    }
}

func (p *PaymentProcessor) handleSubscriptionCreated(event plugnpay.Event) {
    // New customer subscribed - provision access immediately
    var payload plugnpay.SubscriptionEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal subscription event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    planID := payload.Subscription.ProductID

    p.logger.Printf("ðŸŽ‰ New subscriber: %s on plan %s", customerID, planID)

    // Instant provisioning - no webhook delays or failures
    if err := p.enablePremiumFeatures(customerID, planID); err != nil {
        p.logger.Printf("âŒ Failed to provision %s: %v", customerID, err)
        return
    }

    if err := p.sendWelcomeEmail(payload.Customer.Email); err != nil {
        p.logger.Printf("âŒ Failed to send welcome email to %s: %v", payload.Customer.Email, err)
    }

    if err := p.updateUserDashboard(customerID, "premium"); err != nil {
        p.logger.Printf("âŒ Failed to update dashboard for %s: %v", customerID, err)
    }

    p.logger.Printf("âœ… Provisioned access for %s", customerID)
}

func (p *PaymentProcessor) handlePaymentSucceeded(event plugnpay.Event) {
    // Payment confirmed - extend service
    var payload plugnpay.InvoiceEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal invoice event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    amount := payload.Invoice.AmountPaid

    p.logger.Printf("ðŸ’° Payment received: $%.2f from %s", float64(amount)/100, customerID)

    // Process payment instantly
    if err := p.extendServicePeriod(customerID); err != nil {
        p.logger.Printf("âŒ Failed to extend service for %s: %v", customerID, err)
    }

    if err := p.sendReceipt(payload.Customer.Email, amount); err != nil {
        p.logger.Printf("âŒ Failed to send receipt to %s: %v", payload.Customer.Email, err)
    }

    if err := p.updateBillingHistory(customerID, amount); err != nil {
        p.logger.Printf("âŒ Failed to update billing history for %s: %v", customerID, err)
    }
}

func (p *PaymentProcessor) handleSubscriptionCancelled(event plugnpay.Event) {
    // Subscription cancelled - manage gracefully
    var payload plugnpay.SubscriptionEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal subscription event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    p.logger.Printf("ðŸ“‹ Subscription cancelled for %s", customerID)

    // Handle cancellation gracefully
    if err := p.scheduleAccessRevocation(customerID); err != nil {
        p.logger.Printf("âŒ Failed to schedule access revocation for %s: %v", customerID, err)
    }

    if err := p.sendCancellationEmail(payload.Customer.Email); err != nil {
        p.logger.Printf("âŒ Failed to send cancellation email to %s: %v", payload.Customer.Email, err)
    }

    if err := p.triggerWinBackCampaign(customerID); err != nil {
        p.logger.Printf("âŒ Failed to trigger win-back campaign for %s: %v", customerID, err)
    }
}

func (p *PaymentProcessor) handlePaymentFailed(event plugnpay.Event) {
    var payload plugnpay.InvoiceEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal invoice event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    p.logger.Printf("âŒ Payment failed for %s", customerID)

    // Handle payment failure
    if err := p.sendPaymentFailedNotification(customerID, payload.Invoice.URL); err != nil {
        p.logger.Printf("âŒ Failed to send payment failed notification to %s: %v", customerID, err)
    }

    if err := p.pauseServiceAccess(customerID); err != nil {
        p.logger.Printf("âŒ Failed to pause service access for %s: %v", customerID, err)
    }
}

// Helper functions (implement these for your app)
func (p *PaymentProcessor) enablePremiumFeatures(customerID, planID string) error {
    p.logger.Printf("Enabling premium features for %s on plan %s", customerID, planID)
    // Implement premium feature enablement
    return nil
}

func (p *PaymentProcessor) sendWelcomeEmail(email string) error {
    p.logger.Printf("Sending welcome email to %s", email)
    // Implement email sending
    return nil
}

func (p *PaymentProcessor) updateUserDashboard(customerID, tier string) error {
    p.logger.Printf("Updating dashboard for %s to %s tier", customerID, tier)
    // Implement dashboard update
    return nil
}

func (p *PaymentProcessor) extendServicePeriod(customerID string) error {
    p.logger.Printf("Extending service period for %s", customerID)
    // Implement service extension
    return nil
}

func (p *PaymentProcessor) sendReceipt(email string, amount int64) error {
    p.logger.Printf("Sending receipt to %s for $%.2f", email, float64(amount)/100)
    // Implement receipt sending
    return nil
}

func (p *PaymentProcessor) updateBillingHistory(customerID string, amount int64) error {
    p.logger.Printf("Updating billing history for %s: $%.2f", customerID, float64(amount)/100)
    // Implement billing history update
    return nil
}

func (p *PaymentProcessor) scheduleAccessRevocation(customerID string) error {
    p.logger.Printf("Scheduling access revocation for %s", customerID)
    // Implement access revocation scheduling
    return nil
}

func (p *PaymentProcessor) sendCancellationEmail(email string) error {
    p.logger.Printf("Sending cancellation email to %s", email)
    // Implement cancellation email
    return nil
}

func (p *PaymentProcessor) triggerWinBackCampaign(customerID string) error {
    p.logger.Printf("Triggering win-back campaign for %s", customerID)
    // Implement win-back campaign
    return nil
}

func (p *PaymentProcessor) sendPaymentFailedNotification(customerID string, invoiceURL *string) error {
    p.logger.Printf("Sending payment failed notification to %s", customerID)
    // Implement payment failure notification
    return nil
}

func (p *PaymentProcessor) pauseServiceAccess(customerID string) error {
    p.logger.Printf("Pausing service access for %s", customerID)
    // Implement service access pausing
    return nil
}

func main() {
    // Graceful shutdown context
    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    processor, err := NewPaymentProcessor()
    if err != nil {
        log.Fatalf("Failed to create payment processor: %v", err)
    }

    // No webhook server needed - just run your payment processor!
    if err := processor.Start(ctx); err != nil && err != context.Canceled {
        log.Fatalf("Payment processor failed: %v", err)
    }

    log.Println("Payment processor shutdown complete")
}
```

**Key Benefits Demonstrated:**
- âœ… **Zero webhook infrastructure** - no endpoints, no servers, no security concerns
- âœ… **Instant event processing** - no webhook delivery delays or failures
- âœ… **Channel-based concurrency** - perfect for Go's goroutine model
- âœ… **Context-aware cancellation** - proper Go patterns for lifecycle management

## Error Handling

The SDK provides comprehensive error handling following Go conventions with typed errors:

```go
package main

import (
    "context"
    "errors"
    "log"
    "github.com/plugnpay/plugnpay-go"
)

func comprehensiveErrorHandling() {
    ctx := context.Background()
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }

    customer, err := client.GetCustomer(ctx, plugnpay.GetCustomerArgs{
        CusID: "cus_123",
        Email: "test@example.com",
    })
    if err != nil {
        // Check for specific error types
        var authErr *plugnpay.AuthenticationError
        var validationErr *plugnpay.ValidationError
        var rateLimitErr *plugnpay.RateLimitError
        var notFoundErr *plugnpay.NotFoundError
        var serverErr *plugnpay.ServerError

        switch {
        case errors.As(err, &authErr):
            log.Printf("Invalid API key: %v", authErr)
        case errors.As(err, &validationErr):
            log.Printf("Invalid parameters: %v", validationErr)
        case errors.As(err, &rateLimitErr):
            log.Printf("Rate limit exceeded: %v", rateLimitErr)
        case errors.As(err, &notFoundErr):
            log.Printf("Resource not found: %v", notFoundErr)
        case errors.As(err, &serverErr):
            log.Printf("Server error: %v", serverErr)
        case errors.Is(err, context.DeadlineExceeded):
            log.Printf("Request timed out: %v", err)
        case errors.Is(err, context.Canceled):
            log.Printf("Request was cancelled: %v", err)
        default:
            log.Printf("Unexpected error: %v", err)
        }
        return
    }

    log.Printf("Success: %+v", customer)
}
```

### Error Types

```go
// Error hierarchy
type PlugnPayError interface {
    error
    StatusCode() int
    RequestID() string
}

type AuthenticationError struct {
    Message   string
    Code      int
    ReqID     string
}

type ValidationError struct {
    Message   string
    Code      int
    ReqID     string
    Fields    map[string]string // Field-specific validation errors
}

type RateLimitError struct {
    Message     string
    Code        int
    ReqID       string
    RetryAfter  int // Seconds to wait before retrying
}

type NotFoundError struct {
    Message   string
    Code      int
    ReqID     string
}

type ServerError struct {
    Message   string
    Code      int
    ReqID     string
}
```

### Context Timeouts and Cancellation

```go
import "time"

// Set timeout for operations
func withTimeout() error {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    customer, err := client.GetCustomer(ctx, plugnpay.GetCustomerArgs{
        Email: "test@example.com",
    })
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Println("Request timed out after 10 seconds")
        }
        return err
    }

    log.Printf("Customer: %+v", customer)
    return nil
}

// Cancellable operations
func withCancellation() error {
    ctx, cancel := context.WithCancel(context.Background())

    // Cancel after some condition
    go func() {
        time.Sleep(5 * time.Second)
        cancel() // Cancel the operation
    }()

    customer, err := client.GetCustomer(ctx, plugnpay.GetCustomerArgs{
        Email: "test@example.com",
    })
    if err != nil {
        if errors.Is(err, context.Canceled) {
            log.Println("Request was cancelled")
        }
        return err
    }

    log.Printf("Customer: %+v", customer)
    return nil
}
```

## Examples

The SDK includes comprehensive examples in the `examples/` directory:

### Running Examples

Each example is in its own directory and can be run independently:

```bash
# SSE Example
cd examples/sse
go run sse_example.go

# Customer Example
cd examples/customer
go run customer_example.go

# Access Example
cd examples/access
go run access_example.go

# Checkout Example
cd examples/checkout
go run checkout_example.go

# Usage Tracking Example
cd examples/usage
go run track_usage_example.go

# Get Usage Example
cd examples/usage
go run get_usage_example.go
```

### Example Structure

```
examples/
â”œâ”€â”€ constants/
â”‚   â””â”€â”€ constants.go          # Shared constants
â”œâ”€â”€ sse/
â”‚   â””â”€â”€ sse_example.go       # SSE event handling example
â”œâ”€â”€ customer/
â”‚   â””â”€â”€ customer_example.go  # Customer management example
â”œâ”€â”€ access/
â”‚   â””â”€â”€ access_example.go    # Access control example
â”œâ”€â”€ checkout/
â”‚   â””â”€â”€ checkout_example.go  # Checkout session example
â””â”€â”€ usage/
    â”œâ”€â”€ track_usage_example.go # Usage tracking example
    â””â”€â”€ get_usage_example.go   # Get usage example
```

## Complete Integration Example

Here's a comprehensive example showing all major SDK features:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "sync"
    "time"
    "github.com/plugnpay/plugnpay-sdk-go"
    "github.com/plugnpay/plugnpay-sdk-go/services"
    "github.com/plugnpay/plugnpay-sdk-go/services/access"
    "github.com/plugnpay/plugnpay-sdk-go/services/checkout"
    "github.com/plugnpay/plugnpay-sdk-go/services/customer"
    "github.com/plugnpay/plugnpay-sdk-go/services/sse"
    "github.com/plugnpay/plugnpay-sdk-go/services/usage"
)

type PlugnPayService struct {
    client *plugnpay.Client
    mu     sync.RWMutex
}

func NewPlugnPayService() (*PlugnPayService, error) {
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        return nil, err
    }

    return &PlugnPayService{client: client}, nil
}

type CheckoutResult struct {
    CustomerID  string
    CheckoutURL string
    Error       error
}

func (s *PlugnPayService) CreateCustomerAndCheckout(ctx context.Context, email, productID string) CheckoutResult {
    // 1. Customer Management
    customer, err := customer.GetCustomer(s.client, ctx, customer.GetCustomerArgs{
        CusID: "customer_123",
        Email: stringPtr(email),
        Name:  stringPtr("John Doe"),
    })
    if err != nil {
        return CheckoutResult{Error: fmt.Errorf("failed to get customer: %w", err)}
    }
    log.Printf("Customer ID: %s", customer.CustomerID)

    // 2. Create Checkout Session
    checkout, err := checkout.CreateCheckoutSession(s.client, ctx, checkout.CreateCheckoutSessionArgs{
        CustomerID: customer.CustomerID,
        ProductID:  productID,
        SuccessURL: "https://yourapp.com/success",
        CancelURL:  stringPtr("https://yourapp.com/cancel"),
        Provider:   checkout.ProviderStripe,
    })
    if err != nil {
        return CheckoutResult{Error: fmt.Errorf("failed to create checkout: %w", err)}
    }

    return CheckoutResult{
        CustomerID:  customer.CustomerID,
        CheckoutURL: checkout.URL,
    }
}

type AccessResult struct {
    HasAccess bool
    Usage     int64
    Remaining *int64
    Error     error
}

func (s *PlugnPayService) CheckUserAccess(ctx context.Context, customerID, featureID string) AccessResult {
    // 3. Check Access
    access, err := access.CheckAccess(s.client, ctx, access.CheckAccessArgs{
        CustomerID: customerID,
        FeatureID:  featureID,
    })
    if err != nil {
        return AccessResult{Error: fmt.Errorf("failed to check access: %w", err)}
    }

    if !access.HasAccess {
        return AccessResult{HasAccess: false}
    }

    // 4. Track Feature Usage
    _, err = usage.TrackUsage(s.client, ctx, usage.TrackUsageArgs{
        CustomerID:     customerID,
        FeatureID:      "api-calls",
        Usage:          1,
        IdempotencyKey: stringPtr(fmt.Sprintf("op-%d", time.Now().Unix())),
    })
    if err != nil {
        return AccessResult{Error: fmt.Errorf("failed to track usage: %w", err)}
    }

    // 5. Get Usage Statistics
    usage, err := usage.GetUsage(s.client, ctx, usage.GetUsageArgs{
        CustomerID: customerID,
        FeatureID:  "api-calls",
    })
    if err != nil {
        return AccessResult{Error: fmt.Errorf("failed to get usage: %w", err)}
    }

    return AccessResult{
        HasAccess: true,
        Usage:     usage.TotalUsage,
        Remaining: usage.Remaining,
    }
}

func (s *PlugnPayService) StartEventProcessing(ctx context.Context) error {
    // Register event handlers
    s.client.OnEvent("subscription.created", s.handleSubscriptionCreated)
    s.client.OnEvent("payment_intent.succeeded", s.handlePaymentSucceeded)
    
    // Start listening for events
    if err := s.client.StartEvents(ctx); err != nil {
        return err
    }

    log.Println("Started event processing...")

    // Monitor stream channels
    eventChan, errorChan := s.client.StreamEvents(ctx)
    
    for {
        select {
        case <-ctx.Done():
            return ctx.Err()

        case err := <-errorChan:
            log.Printf("Event stream error: %v", err)
            return err

        case event := <-eventChan:
            if event != nil {
                // Events are handled by registered handlers
                log.Printf("Received event: %s", event.WebhookEventType)
            }
        }
    }
}

func (s *PlugnPayService) handleSubscriptionCreated(event *sse.SSEEvent) error {
    log.Printf("New subscription for %s", event.CustomerID)
    return nil
}

func (s *PlugnPayService) handlePaymentSucceeded(event *sse.SSEEvent) error {
    log.Printf("Payment successful for %s", event.CustomerID)
    return nil
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    service, err := NewPlugnPayService()
    if err != nil {
        log.Fatalf("Failed to create service: %v", err)
    }

    // Create checkout for a customer
    checkoutResult := service.CreateCustomerAndCheckout(ctx, "customer@example.com", "premium-plan")
    if checkoutResult.Error != nil {
        log.Fatalf("Checkout failed: %v", checkoutResult.Error)
    }

    fmt.Printf("Redirect to: %s\n", checkoutResult.CheckoutURL)

    // Check if user has access to features
    accessResult := service.CheckUserAccess(ctx, checkoutResult.CustomerID, "premium-features")
    if accessResult.Error != nil {
        log.Fatalf("Access check failed: %v", accessResult.Error)
    }

    if accessResult.HasAccess {
        fmt.Printf("Feature access granted. Usage: %d\n", accessResult.Usage)
        if accessResult.Remaining != nil {
            fmt.Printf("Remaining: %d\n", *accessResult.Remaining)
        }
    } else {
        fmt.Println("Upgrade required for this feature")
    }

    // Start event processing (this would run indefinitely in a real app)
    // go service.StartEventProcessing(context.Background())
}

// Helper function for string pointers
func stringPtr(s string) *string {
    return &s
}
```

## Framework Integrations

### Gin Integration

```go
package main

import (
    "context"
    "net/http"
    "github.com/gin-gonic/gin"
    "github.com/plugnpay/plugnpay-go"
)

func main() {
    // Initialize PlugnPay client
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        panic(err)
    }

    r := gin.Default()

    // Create checkout endpoint
    r.POST("/checkout", func(c *gin.Context) {
        var req struct {
            Email     string `json:"email" binding:"required"`
            ProductID string `json:"product_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Get or create customer
        customer, err := client.GetCustomer(c.Request.Context(), plugnpay.GetCustomerArgs{
            Email: req.Email,
        })
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get customer"})
            return
        }

        // Create checkout session
        session, err := client.CreateCheckoutSession(c.Request.Context(), plugnpay.CreateCheckoutSessionArgs{
            CustomerID: customer.CustomerID,
            ProductID:  req.ProductID,
            SuccessURL: "https://yourapp.com/success",
            CancelURL:  stringPtr("https://yourapp.com/cancel"),
        })
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create checkout"})
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "checkout_url": session.URL,
            "customer_id":  customer.CustomerID,
        })
    })

    // Check access endpoint
    r.GET("/access/:customer_id/:feature_id", func(c *gin.Context) {
        customerID := c.Param("customer_id")
        featureID := c.Param("feature_id")

        access, err := client.CheckAccess(c.Request.Context(), plugnpay.CheckAccessArgs{
            CustomerID: customerID,
            FeatureID:  featureID,
        })
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check access"})
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "has_access": access.HasAccess,
            "remaining":  access.UsageRemaining,
        })
    })

    r.Run(":8080")
}
```

### Echo Integration

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
    "github.com/plugnpay/plugnpay-go"
)

func main() {
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        panic(err)
    }

    e := echo.New()

    e.POST("/checkout", func(c echo.Context) error {
        var req struct {
            Email     string `json:"email"`
            ProductID string `json:"product_id"`
        }

        if err := c.Bind(&req); err != nil {
            return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
        }

        customer, err := client.GetCustomer(c.Request().Context(), plugnpay.GetCustomerArgs{
            Email: req.Email,
        })
        if err != nil {
            return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to get customer"})
        }

        session, err := client.CreateCheckoutSession(c.Request().Context(), plugnpay.CreateCheckoutSessionArgs{
            CustomerID: customer.CustomerID,
            ProductID:  req.ProductID,
            SuccessURL: "https://yourapp.com/success",
        })
        if err != nil {
            return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create checkout"})
        }

        return c.JSON(http.StatusOK, map[string]interface{}{
            "checkout_url": session.URL,
            "customer_id":  customer.CustomerID,
        })
    })

    e.Logger.Fatal(e.Start(":8080"))
}
```

### Fiber Integration

```go
package main

import (
    "github.com/gofiber/fiber/v2"
    "github.com/plugnpay/plugnpay-go"
)

func main() {
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        panic(err)
    }

    app := fiber.New()

    app.Post("/checkout", func(c *fiber.Ctx) error {
        var req struct {
            Email     string `json:"email"`
            ProductID string `json:"product_id"`
        }

        if err := c.BodyParser(&req); err != nil {
            return c.Status(400).JSON(fiber.Map{"error": err.Error()})
        }

        customer, err := client.GetCustomer(c.Context(), plugnpay.GetCustomerArgs{
            Email: req.Email,
        })
        if err != nil {
            return c.Status(500).JSON(fiber.Map{"error": "Failed to get customer"})
        }

        session, err := client.CreateCheckoutSession(c.Context(), plugnpay.CreateCheckoutSessionArgs{
            CustomerID: customer.CustomerID,
            ProductID:  req.ProductID,
            SuccessURL: "https://yourapp.com/success",
        })
        if err != nil {
            return c.Status(500).JSON(fiber.Map{"error": "Failed to create checkout"})
        }

        return c.JSON(fiber.Map{
            "checkout_url": session.URL,
            "customer_id":  customer.CustomerID,
        })
    })

    app.Listen(":8080")
}
```

## Concurrency and Thread Safety

The `*Client` is safe for concurrent use across multiple goroutines:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "sync"
    "github.com/plugnpay/plugnpay-go"
)

func main() {
    client, err := plugnpay.NewClient(nil)
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }

    ctx := context.Background()
    var wg sync.WaitGroup

    // Safe to use the same client from multiple goroutines
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()

            customer, err := client.GetCustomer(ctx, plugnpay.GetCustomerArgs{
                Email: fmt.Sprintf("user%d@example.com", id),
            })
            if err != nil {
                log.Printf("Goroutine %d failed: %v", id, err)
                return
            }

            log.Printf("Goroutine %d: Customer %s", id, customer.CustomerID)
        }(i)
    }

    wg.Wait()
    log.Println("All goroutines completed")
}
```

## Type Definitions

The Go SDK provides comprehensive type definitions for all API responses and configurations:

```go
// Core configuration
type Config struct {
    APIKey     string        // Required: PlugnPay API key
    BaseURL    string        // Optional: Custom API base URL
    HTTPClient *http.Client  // Optional: Custom HTTP client
    UserAgent  string        // Optional: Custom User-Agent header
}

// Payment provider options
type Provider string

const (
    ProviderStripe Provider = "stripe"
)

// Complete type definitions for all API operations...
```

This completes the comprehensive PlugnPay Go SDK documentation. The SDK provides idiomatic Go patterns with channels, context support, and explicit error handling for all your payment and subscription management needs.