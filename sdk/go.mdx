---
title: Go SDK
description: Complete guide for integrating SnapPay with Go applications using idiomatic Go patterns and concurrency
---

## Overview

The SnapPay Go SDK provides a comprehensive, idiomatic interface for integrating payment processing, subscription management, and real-time event streaming into your Go applications. Built with modern Go patterns including context support, channel-based concurrency, and explicit error handling, it offers seamless integration with SnapPay's platform.

**Requirements:** Go 1.21+

### Key Features

- **Idiomatic Go design** with context.Context support for cancellation and timeouts
- **Channel-based concurrency** for optimal performance and real-time event handling
- **Explicit error handling** following Go conventions
- **Full type safety** with struct definitions and interface contracts
- **Goroutine-safe client** for concurrent usage across your application
- **Real-time event streaming** via Server-Sent Events (SSE) using channels
- **Context-aware operations** with deadline propagation and cancellation
- **Environment-based configuration** with sensible defaults

## Installation

```bash
go get github.com/snappay/snappay-go
```

Add to your `go.mod`:

```go
module your-app

go 1.21

require (
    github.com/snappay/snappay-go v1.0.0
)
```

## Configuration & Initialization

The SDK client is configured via a constructor function that accepts an optional configuration struct. All operations support context.Context for proper timeout and cancellation handling.

### API Key Authentication

Authentication is handled via an API key that must start with `pk_test_` (for testing) or `pk_live_` (for production). Configure your API key in one of these ways:

**Environment Variable (Recommended):**

```bash
export SNAPPAY_API_KEY="pk_test_xxxxxxxxxx"
```

**Direct Configuration:**

```go
package main

import (
    "context"
    "log"
    "github.com/snappay/snappay-go"
    "github.com/snappay/snappay-go/services"
)

func main() {
    // Using environment variable (recommended)
    client, err := snappay.NewClient(nil)
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }

    // Using direct API key
    client, err = snappay.NewClient(&services.Config{
        APIKey: "pk_test_xxxxxxxxxx",
    })
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }
}
```

### Advanced Configuration

```go
import (
    "net/http"
    "time"
    "github.com/snappay/snappay-go/services"
)

config := &services.Config{
    APIKey:     "pk_test_xxxxxxxxxx",
    BaseURL:    "https://api.snappay.dev",  // Custom base URL
    HTTPClient: &http.Client{                // Custom HTTP client
        Timeout: 30 * time.Second,
    },
    UserAgent: "MyApp/1.0.0",               // Custom user agent
}

client, err := snappay.NewClient(config)
if err != nil {
    log.Fatalf("Failed to create client: %v", err)
}
```

## Core Methods

All methods accept a `context.Context` as the first parameter and return a result struct pointer and an error, following standard Go patterns. The client is safe for concurrent use across multiple goroutines.

### Customer Management

#### GetCustomer

Retrieves or creates a customer record (upsert logic).

```go
import "github.com/snappay/snappay-go/services/customer"

ctx := context.Background()
customer, err := customer.Get(client, ctx, customer.GetCustomerArgs{
    CusID: "cus_123",
    Email: stringPtr("user@example.com"),
    Name:  stringPtr("John Doe"), // Optional
})
if err != nil {
    log.Fatalf("Failed to get customer: %v", err)
}
fmt.Printf("Customer ID: %s\n", customer.CustomerID)
```

**Parameters:**

- `CusID` (string): Customer identifier
- `Email` (\*string): Customer email address (optional)
- `Name` (\*string): Customer full name (optional)

**Returns:** `(*Customer, error)`

```go
type Customer struct {
    CustomerID string  `json:"customer_id"` // SnapPay customer ID
    Email      string  `json:"email"`       // Customer email
    Name       *string `json:"name"`        // Customer name (optional)
    Status     string  `json:"status"`      // Customer account status
    Env        string  `json:"env"`         // Environment (test/live)
    CreatedAt  *string `json:"created_at"`  // Creation timestamp
    UpdatedAt  *string `json:"updated_at"`  // Last update timestamp
}
```

### Checkout Sessions

#### CreateCheckoutSession

Creates a payment checkout session URL for customer purchases.

```go
import "github.com/snappay/snappay-go/services/checkout"

ctx := context.Background()
session, err := checkout.CreateSession(client, ctx, checkout.CreateCheckoutSessionArgs{
    CustomerID: "cus_123",
    ProductID:  "premium-plan",
    SuccessURL: "https://yourapp.com/success",
    CancelURL:  stringPtr("https://yourapp.com/cancel"), // Optional
    Provider:   checkout.ProviderStripe,                  // Default: stripe
    Metadata: map[string]string{                          // Optional
        "order_id": "ord_456",
    },
})
if err != nil {
    log.Fatalf("Failed to create checkout session: %v", err)
}
fmt.Printf("Checkout URL: %s\n", session.URL)
```

**Parameters:**

- `CustomerID` (string): SnapPay customer ID
- `ProductID` (string): Product ID from your snappay dashboard
- `SuccessURL` (string): URL to redirect after successful payment
- `CancelURL` (\*string): URL to redirect on cancellation (optional)
- `Provider` (Provider): Payment provider (defaults to ProviderStripe)
- `Metadata` (map[string]string): Additional checkout parameters (optional)

**Returns:** `(*CheckoutSession, error)`

```go
type CheckoutSession struct {
    SessionID string  `json:"session_id"` // Unique session identifier
    URL       string  `json:"url"`        // Checkout URL for customer
    ExpiresAt string  `json:"expires_at"` // Session expiration timestamp
}
```

### Access Control

#### CheckAccess

Checks if a customer has access to a specific feature based on their subscription and usage limits.

```go
import "github.com/snappay/snappay-go/services/access"

ctx := context.Background()
access, err := access.Check(client, ctx, access.CheckAccessArgs{
    CustomerID: "cus_123",
    FeatureID:  "premium-features",
})
if err != nil {
    log.Fatalf("Failed to check access: %v", err)
}

if access.HasAccess {
    if access.Usage != nil && access.Allowance != nil {
        remaining := *access.Allowance - *access.Usage
        fmt.Printf("Access granted. %d/%d used\n", *access.Usage, *access.Allowance)
        fmt.Printf("Remaining: %d\n", remaining)
    } else {
        fmt.Println("Access granted (unlimited feature)")
    }
} else {
    fmt.Println("Access denied. Upgrade required.")
}
```

**Parameters:**

- `CustomerID` (string): SnapPay customer ID
- `FeatureID` (string): Feature identifier

**Returns:** `(*AccessCheck, error)`

```go
type AccessCheck struct {
    HasAccess   bool   `json:"has_access"`
    FeatureID   string `json:"feature_id"`
    Usage       *int64 `json:"usage"`
    Allowance   *int64 `json:"allowance"`
    NextResetAt *int64 `json:"next_reset_at"`
}
```

### Usage Tracking

#### TrackUsage

Reports usage for a metered feature. This action is idempotent to prevent duplicate tracking.

```go
import "github.com/snappay/snappay-go/services/usage"

ctx := context.Background()
result, err := usage.Track(client, ctx, usage.TrackUsageArgs{
    CustomerID:     "cus_123",
    FeatureID:      "ai-messages",
    Usage:          1,   // integer usage units
    IdempotencyKey: stringPtr("unique-operation-123"), // Optional
})
if err != nil {
    log.Fatalf("Failed to track usage: %v", err)
}
fmt.Printf("Tracked %d units. Total: %d (idempotency: %v)\n", result.Added, result.Used, result.IdempotencyKey)
```

**Parameters:**

- `CustomerID` (string): SnapPay customer ID
- `FeatureID` (string): Feature identifier for usage tracking
- `Usage` (float64): Usage amount to track
- `IdempotencyKey` (\*string): Prevents duplicate tracking (optional)

**Returns:** `(*TrackUsageResponse, error)`

```go
type TrackUsageResponse struct {
    Success bool `json:"success"` // Tracking confirmation
}
```

#### GetUsage

Retrieves current usage details for a customer's feature.

```go
ctx := context.Background()
items, err := usage.Get(client, ctx, usage.GetUsageArgs{
    CustomerID: "cus_123",
    FeatureID:  "ai-messages",
})
if err != nil {
    log.Fatalf("Failed to get usage: %v", err)
}
for _, u := range *items {
    fmt.Printf("Total usage: %d\n", u.TotalUsage)
    if u.Remaining != nil { fmt.Printf("Remaining: %d\n", *u.Remaining) }
    if u.Limit != nil { fmt.Printf("Limit: %d\n", *u.Limit) }
}
```

**Parameters:**

- `CustomerID` (string): SnapPay customer ID
- `FeatureID` (string): Feature identifier

**Returns:** `(*GetUsageResponse, error)`

```go
type GetUsageResponse struct {
    Limit      *int64 `json:"limit"`       // Total limit for period (nil for unlimited)
    TotalUsage int64  `json:"total_usage"` // Total usage in current billing period
    Remaining  *int64 `json:"remaining"`   // Remaining usage (nil if limit is nil)
}
```

## Real-time Event Handling

**Say goodbye to webhook hell!** snappay eliminates the complexity of managing payment webhooks by processing all provider webhooks (Stripe, PayPal, etc.) internally and delivering clean, structured events directly to your application via Server-Sent Events (SSE) using Go channels.

### ðŸš« What You DON'T Need:

- **No webhook endpoints** to create and maintain
- **No webhook signature verification**
- **No webhook retry logic** or failure handling
- **No webhook security concerns**
- **No debugging webhook delivery issues**

### âœ… What You GET:

- **Real-time events** delivered instantly via Go channels
- **Guaranteed delivery** with automatic reconnection
- **Clean, structured data** - no raw webhook payloads
- **Channel-based concurrency** perfect for Go's goroutine model
- **Context-aware** with proper cancellation support

### Channel-Based Event Streaming

Receive events via channels and handle them with context-aware loops:

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "os/signal"
    "syscall"
    "github.com/snappay/snappay-go"
    "github.com/snappay/snappay-go/services/sse"
)

func main() {
    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    client, err := snappay.NewClient(nil)
    if err != nil { log.Fatalf("Failed to create client: %v", err) }

    // Register handlers (optional)
    client.OnEvent(sse.EventTypeSubscriptionUpdated, func(ev *sse.SSEEvent) error {
        data, err := ev.GetSubscriptionData()
        if err == nil {
            log.Printf("Subscription updated for %s: %s", data.CustomerID, data.PaymentStatus)
        }
        return nil
    })

    // Stream events
    evCh, errCh := client.StreamEvents(ctx)
    for {
        select {
        case <-ctx.Done():
            return
        case err := <-errCh:
            log.Printf("stream error: %v", err)
            return
        case ev := <-evCh:
            if ev.Type == sse.EventTypeSubscriptionUpdated {
                var payload sse.SubscriptionUpdatedData
                if err := json.Unmarshal(ev.Data, &payload); err == nil {
                    log.Printf("Updated: %+v", payload)
                }
            }
        }
    }
}
```

### Event Structure

snappay transforms raw webhook payloads from payment providers into clean, structured event objects:

```go
// Event represents a single message from the event stream
type Event struct {
    EventID     string          `json:"event_id"`      // Unique event identifier
    EventType   string          `json:"event_type"`    // Standardized event type
    CustomerID  string          `json:"customer_id"`   // Your customer ID
    Data        json.RawMessage `json:"data"`          // Relevant data only
    CreatedAt   string          `json:"created_at"`    // Event timestamp
}

// Event payload types for type-safe unmarshaling
type SubscriptionEventData struct {
    Customer     Customer     `json:"customer"`
    Subscription Subscription `json:"subscription"`
}

type InvoiceEventData struct {
    Customer Customer `json:"customer"`
    Invoice  Invoice  `json:"invoice"`
}

type Subscription struct {
    ID                   string `json:"id"`
    StripeSubscriptionID string `json:"stripe_subscription_id"`
    Status               string `json:"status"` // 'active', 'past_due', 'canceled', etc.
    CurrentPeriodStart   string `json:"current_period_start"`
    CurrentPeriodEnd     string `json:"current_period_end"`
    ProductID            string `json:"product_id"`
}

type Invoice struct {
    ID              string  `json:"id"`
    StripeInvoiceID string  `json:"stripe_invoice_id"`
    Status          string  `json:"status"` // 'paid', 'open', 'void', etc.
    AmountDue       int64   `json:"amount_due"`   // In cents
    AmountPaid      int64   `json:"amount_paid"`  // In cents
    Currency        string  `json:"currency"`
    URL             *string `json:"url"` // Hosted invoice URL from Stripe
}
```

### Production-Ready Event Handling

Here's a complete example showing how snappay eliminates webhook complexity for a SaaS application:

```go
package main

import (
    "context"
    "encoding/json"
    "log"
    "os/signal"
    "sync"
    "syscall"
    "time"
    "github.com/snappay/snappay-go"
)

type PaymentProcessor struct {
    client *snappay.Client
    logger *log.Logger
    wg     sync.WaitGroup
}

func NewPaymentProcessor() (*PaymentProcessor, error) {
    client, err := snappay.NewClient(nil)
    if err != nil {
        return nil, err
    }

    return &PaymentProcessor{
        client: client,
        logger: log.Default(),
    }, nil
}

func (p *PaymentProcessor) Start(ctx context.Context) error {
    p.logger.Println("ðŸš€ Starting payment processor (no webhooks needed)")

    eventCh, errCh, err := p.client.ListenForEvents(ctx)
    if err != nil {
        return err
    }

    p.logger.Println("âœ¨ Payment processor running - webhook-free architecture!")

    for {
        select {
        case <-ctx.Done():
            p.logger.Println("Shutting down payment processor...")
            p.wg.Wait() // Wait for all event processing to complete
            return ctx.Err()

        case err := <-errCh:
            p.logger.Printf("âŒ Event stream error: %v", err)
            // Implement exponential backoff retry logic
            time.Sleep(5 * time.Second)
            return err

        case event := <-eventCh:
            // Process events concurrently
            p.wg.Add(1)
            go func(e snappay.Event) {
                defer p.wg.Done()
                p.processEvent(e)
            }(event)
        }
    }
}

func (p *PaymentProcessor) processEvent(event snappay.Event) {
    p.logger.Printf("Processing event %s: %s", event.EventID, event.EventType)

    switch event.EventType {
    case "subscription.created":
        p.handleSubscriptionCreated(event)
    case "subscription.updated":
        p.handleSubscriptionUpdated(event)
    case "subscription.deleted":
        p.handleSubscriptionCancelled(event)
    case "invoice.payment.succeeded":
        p.handlePaymentSucceeded(event)
    case "invoice.payment.failed":
        p.handlePaymentFailed(event)
    default:
        p.logger.Printf("Unhandled event type: %s", event.EventType)
    }
}

func (p *PaymentProcessor) handleSubscriptionCreated(event snappay.Event) {
    // New customer subscribed - provision access immediately
    var payload snappay.SubscriptionEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal subscription event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    planID := payload.Subscription.ProductID

    p.logger.Printf("ðŸŽ‰ New subscriber: %s on plan %s", customerID, planID)

    // Instant provisioning - no webhook delays or failures
    if err := p.enablePremiumFeatures(customerID, planID); err != nil {
        p.logger.Printf("âŒ Failed to provision %s: %v", customerID, err)
        return
    }

    if err := p.sendWelcomeEmail(payload.Customer.Email); err != nil {
        p.logger.Printf("âŒ Failed to send welcome email to %s: %v", payload.Customer.Email, err)
    }

    if err := p.updateUserDashboard(customerID, "premium"); err != nil {
        p.logger.Printf("âŒ Failed to update dashboard for %s: %v", customerID, err)
    }

    p.logger.Printf("âœ… Provisioned access for %s", customerID)
}

func (p *PaymentProcessor) handlePaymentSucceeded(event snappay.Event) {
    // Payment confirmed - extend service
    var payload snappay.InvoiceEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal invoice event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    amount := payload.Invoice.AmountPaid

    p.logger.Printf("ðŸ’° Payment received: $%.2f from %s", float64(amount)/100, customerID)

    // Process payment instantly
    if err := p.extendServicePeriod(customerID); err != nil {
        p.logger.Printf("âŒ Failed to extend service for %s: %v", customerID, err)
    }

    if err := p.sendReceipt(payload.Customer.Email, amount); err != nil {
        p.logger.Printf("âŒ Failed to send receipt to %s: %v", payload.Customer.Email, err)
    }

    if err := p.updateBillingHistory(customerID, amount); err != nil {
        p.logger.Printf("âŒ Failed to update billing history for %s: %v", customerID, err)
    }
}

func (p *PaymentProcessor) handleSubscriptionCancelled(event snappay.Event) {
    // Subscription cancelled - manage gracefully
    var payload snappay.SubscriptionEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal subscription event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    p.logger.Printf("ðŸ“‹ Subscription cancelled for %s", customerID)

    // Handle cancellation gracefully
    if err := p.scheduleAccessRevocation(customerID); err != nil {
        p.logger.Printf("âŒ Failed to schedule access revocation for %s: %v", customerID, err)
    }

    if err := p.sendCancellationEmail(payload.Customer.Email); err != nil {
        p.logger.Printf("âŒ Failed to send cancellation email to %s: %v", payload.Customer.Email, err)
    }

    if err := p.triggerWinBackCampaign(customerID); err != nil {
        p.logger.Printf("âŒ Failed to trigger win-back campaign for %s: %v", customerID, err)
    }
}

func (p *PaymentProcessor) handlePaymentFailed(event snappay.Event) {
    var payload snappay.InvoiceEventData
    if err := json.Unmarshal(event.Data, &payload); err != nil {
        p.logger.Printf("âŒ Failed to unmarshal invoice event: %v", err)
        return
    }

    customerID := payload.Customer.CustomerID
    p.logger.Printf("âŒ Payment failed for %s", customerID)

    // Handle payment failure
    if err := p.sendPaymentFailedNotification(customerID, payload.Invoice.URL); err != nil {
        p.logger.Printf("âŒ Failed to send payment failed notification to %s: %v", customerID, err)
    }

    if err := p.pauseServiceAccess(customerID); err != nil {
        p.logger.Printf("âŒ Failed to pause service access for %s: %v", customerID, err)
    }
}

// Helper functions (implement these for your app)
func (p *PaymentProcessor) enablePremiumFeatures(customerID, planID string) error {
    p.logger.Printf("Enabling premium features for %s on plan %s", customerID, planID)
    // Implement premium feature enablement
    return nil
}

func (p *PaymentProcessor) sendWelcomeEmail(email string) error {
    p.logger.Printf("Sending welcome email to %s", email)
    // Implement email sending
    return nil
}

func (p *PaymentProcessor) updateUserDashboard(customerID, tier string) error {
    p.logger.Printf("Updating dashboard for %s to %s tier", customerID, tier)
    // Implement dashboard update
    return nil
}

func (p *PaymentProcessor) extendServicePeriod(customerID string) error {
    p.logger.Printf("Extending service period for %s", customerID)
    // Implement service extension
    return nil
}

func (p *PaymentProcessor) sendReceipt(email string, amount int64) error {
    p.logger.Printf("Sending receipt to %s for $%.2f", email, float64(amount)/100)
    // Implement receipt sending
    return nil
}

func (p *PaymentProcessor) updateBillingHistory(customerID string, amount int64) error {
    p.logger.Printf("Updating billing history for %s: $%.2f", customerID, float64(amount)/100)
    // Implement billing history update
    return nil
}

func (p *PaymentProcessor) scheduleAccessRevocation(customerID string) error {
    p.logger.Printf("Scheduling access revocation for %s", customerID)
    // Implement access revocation scheduling
    return nil
}

func (p *PaymentProcessor) sendCancellationEmail(email string) error {
    p.logger.Printf("Sending cancellation email to %s", email)
    // Implement cancellation email
    return nil
}

func (p *PaymentProcessor) triggerWinBackCampaign(customerID string) error {
    p.logger.Printf("Triggering win-back campaign for %s", customerID)
    // Implement win-back campaign
    return nil
}

func (p *PaymentProcessor) sendPaymentFailedNotification(customerID string, invoiceURL *string) error {
    p.logger.Printf("Sending payment failed notification to %s", customerID)
    // Implement payment failure notification
    return nil
}

func (p *PaymentProcessor) pauseServiceAccess(customerID string) error {
    p.logger.Printf("Pausing service access for %s", customerID)
    // Implement service access pausing
    return nil
}

func main() {
    // Graceful shutdown context
    ctx, stop := signal.NotifyContext(context.Background(), syscall.SIGINT, syscall.SIGTERM)
    defer stop()

    processor, err := NewPaymentProcessor()
    if err != nil {
        log.Fatalf("Failed to create payment processor: %v", err)
    }

    // No webhook server needed - just run your payment processor!
    if err := processor.Start(ctx); err != nil && err != context.Canceled {
        log.Fatalf("Payment processor failed: %v", err)
    }

    log.Println("Payment processor shutdown complete")
}
```

**Key Benefits Demonstrated:**

- âœ… **Zero webhook infrastructure** - no endpoints, no servers, no security concerns
- âœ… **Instant event processing** - no webhook delivery delays or failures
- âœ… **Channel-based concurrency** - perfect for Go's goroutine model
- âœ… **Context-aware cancellation** - proper Go patterns for lifecycle management

## Error Handling

The SDK provides comprehensive error handling following Go conventions with typed errors:

```go
package main

import (
    "context"
    "errors"
    "log"
    "github.com/snappay/snappay-go"
)

func comprehensiveErrorHandling() {
    ctx := context.Background()
    client, err := snappay.NewClient(nil)
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }

    customer, err := client.GetCustomer(ctx, snappay.GetCustomerArgs{
        CusID: "cus_123",
        Email: "test@example.com",
    })
    if err != nil {
        // Check for specific error types
        var authErr *snappay.AuthenticationError
        var validationErr *snappay.ValidationError
        var rateLimitErr *snappay.RateLimitError
        var notFoundErr *snappay.NotFoundError
        var serverErr *snappay.ServerError

        switch {
        case errors.As(err, &authErr):
            log.Printf("Invalid API key: %v", authErr)
        case errors.As(err, &validationErr):
            log.Printf("Invalid parameters: %v", validationErr)
        case errors.As(err, &rateLimitErr):
            log.Printf("Rate limit exceeded: %v", rateLimitErr)
        case errors.As(err, &notFoundErr):
            log.Printf("Resource not found: %v", notFoundErr)
        case errors.As(err, &serverErr):
            log.Printf("Server error: %v", serverErr)
        case errors.Is(err, context.DeadlineExceeded):
            log.Printf("Request timed out: %v", err)
        case errors.Is(err, context.Canceled):
            log.Printf("Request was cancelled: %v", err)
        default:
            log.Printf("Unexpected error: %v", err)
        }
        return
    }

    log.Printf("Success: %+v", customer)
}
```

### Error Types

```go
// Error hierarchy
type SnapPayError interface {
    error
    StatusCode() int
    RequestID() string
}

type AuthenticationError struct {
    Message   string
    Code      int
    ReqID     string
}

type ValidationError struct {
    Message   string
    Code      int
    ReqID     string
    Fields    map[string]string // Field-specific validation errors
}

type RateLimitError struct {
    Message     string
    Code        int
    ReqID       string
    RetryAfter  int // Seconds to wait before retrying
}

type NotFoundError struct {
    Message   string
    Code      int
    ReqID     string
}

type ServerError struct {
    Message   string
    Code      int
    ReqID     string
}
```

### Context Timeouts and Cancellation

```go
import "time"

// Set timeout for operations
func withTimeout() error {
    ctx, cancel := context.WithTimeout(context.Background(), 10*time.Second)
    defer cancel()

    customer, err := client.GetCustomer(ctx, snappay.GetCustomerArgs{
        Email: "test@example.com",
    })
    if err != nil {
        if errors.Is(err, context.DeadlineExceeded) {
            log.Println("Request timed out after 10 seconds")
        }
        return err
    }

    log.Printf("Customer: %+v", customer)
    return nil
}

// Cancellable operations
func withCancellation() error {
    ctx, cancel := context.WithCancel(context.Background())

    // Cancel after some condition
    go func() {
        time.Sleep(5 * time.Second)
        cancel() // Cancel the operation
    }()

    customer, err := client.GetCustomer(ctx, snappay.GetCustomerArgs{
        Email: "test@example.com",
    })
    if err != nil {
        if errors.Is(err, context.Canceled) {
            log.Println("Request was cancelled")
        }
        return err
    }

    log.Printf("Customer: %+v", customer)
    return nil
}
```

## Complete Integration Example

Here's a comprehensive example showing all major SDK features:

```go
package main

import (
    "context"
    "encoding/json"
    "fmt"
    "log"
    "sync"
    "time"
    "github.com/snappay/snappay-go"
)

type SnapPayService struct {
    client *snappay.Client
    mu     sync.RWMutex
}

func NewSnapPayService() (*SnapPayService, error) {
    client, err := snappay.NewClient(nil)
    if err != nil {
        return nil, err
    }

    return &SnapPayService{client: client}, nil
}

type CheckoutResult struct {
    CustomerID  string
    CheckoutURL string
    Error       error
}

func (s *SnapPayService) CreateCustomerAndCheckout(ctx context.Context, email, productID string) CheckoutResult {
    // 1. Customer Management
    customer, err := s.client.GetCustomer(ctx, snappay.GetCustomerArgs{
        CusID: "customer_123",
        Email: email,
        Name:  stringPtr("John Doe"),
    })
    if err != nil {
        return CheckoutResult{Error: fmt.Errorf("failed to get customer: %w", err)}
    }
    log.Printf("Customer ID: %s", customer.CustomerID)

    // 2. Create Checkout Session
    checkout, err := s.client.CreateCheckoutSession(ctx, snappay.CreateCheckoutSessionArgs{
        CustomerID: customer.CustomerID,
        ProductID:  productID,
        SuccessURL: "https://yourapp.com/success",
        CancelURL:  stringPtr("https://yourapp.com/cancel"),
        Provider:   snappay.ProviderStripe,
    })
    if err != nil {
        return CheckoutResult{Error: fmt.Errorf("failed to create checkout: %w", err)}
    }

    return CheckoutResult{
        CustomerID:  customer.CustomerID,
        CheckoutURL: checkout.URL,
    }
}

type AccessResult struct {
    HasAccess bool
    Usage     int64
    Remaining *int64
    Error     error
}

func (s *SnapPayService) CheckUserAccess(ctx context.Context, customerID, featureID string) AccessResult {
    // 3. Check Access
    access, err := s.client.CheckAccess(ctx, snappay.CheckAccessArgs{
        CustomerID: customerID,
        FeatureID:  featureID,
    })
    if err != nil {
        return AccessResult{Error: fmt.Errorf("failed to check access: %w", err)}
    }

    if !access.HasAccess {
        return AccessResult{HasAccess: false}
    }

    // 4. Track Feature Usage
    _, err = s.client.TrackUsage(ctx, snappay.TrackUsageArgs{
        CustomerID:     customerID,
        FeatureID:      "api-calls",
        Usage:          1,
        IdempotencyKey: stringPtr(fmt.Sprintf("op-%d", time.Now().Unix())),
    })
    if err != nil {
        return AccessResult{Error: fmt.Errorf("failed to track usage: %w", err)}
    }

    // 5. Get Usage Statistics
    usage, err := s.client.GetUsage(ctx, snappay.GetUsageArgs{
        CustomerID: customerID,
        FeatureID:  "api-calls",
    })
    if err != nil {
        return AccessResult{Error: fmt.Errorf("failed to get usage: %w", err)}
    }

    return AccessResult{
        HasAccess: true,
        Usage:     usage.TotalUsage,
        Remaining: usage.Remaining,
    }
}

func (s *SnapPayService) StartEventProcessing(ctx context.Context) error {
    eventCh, errCh, err := s.client.ListenForEvents(ctx)
    if err != nil {
        return err
    }

    log.Println("Started event processing...")

    for {
        select {
        case <-ctx.Done():
            return ctx.Err()

        case err := <-errCh:
            log.Printf("Event stream error: %v", err)
            return err

        case event := <-eventCh:
            go s.handleEvent(event) // Process events concurrently
        }
    }
}

func (s *SnapPayService) handleEvent(event snappay.Event) {
    switch event.EventType {
    case "subscription.created":
        var payload snappay.SubscriptionEventData
        if err := json.Unmarshal(event.Data, &payload); err != nil {
            log.Printf("Error unmarshaling subscription event: %v", err)
            return
        }
        log.Printf("New subscription for %s", payload.Customer.Email)

    case "payment_intent.succeeded":
        var payload snappay.InvoiceEventData
        if err := json.Unmarshal(event.Data, &payload); err != nil {
            log.Printf("Error unmarshaling invoice event: %v", err)
            return
        }
        log.Printf("Payment successful for %s", payload.Customer.Email)
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
    defer cancel()

    service, err := NewSnapPayService()
    if err != nil {
        log.Fatalf("Failed to create service: %v", err)
    }

    // Create checkout for a customer
    checkoutResult := service.CreateCustomerAndCheckout(ctx, "customer@example.com", "premium-plan")
    if checkoutResult.Error != nil {
        log.Fatalf("Checkout failed: %v", checkoutResult.Error)
    }

    fmt.Printf("Redirect to: %s\n", checkoutResult.CheckoutURL)

    // Check if user has access to features
    accessResult := service.CheckUserAccess(ctx, checkoutResult.CustomerID, "premium-features")
    if accessResult.Error != nil {
        log.Fatalf("Access check failed: %v", accessResult.Error)
    }

    if accessResult.HasAccess {
        fmt.Printf("Feature access granted. Usage: %d\n", accessResult.Usage)
        if accessResult.Remaining != nil {
            fmt.Printf("Remaining: %d\n", *accessResult.Remaining)
        }
    } else {
        fmt.Println("Upgrade required for this feature")
    }

    // Start event processing (this would run indefinitely in a real app)
    // go service.StartEventProcessing(context.Background())
}

// Helper function for string pointers
func stringPtr(s string) *string {
    return &s
}
```

## Framework Integrations

### Gin Integration

```go
package main

import (
    "context"
    "net/http"
    "github.com/gin-gonic/gin"
    "github.com/snappay/snappay-go"
)

func main() {
    // Initialize snappay client
    client, err := snappay.NewClient(nil)
    if err != nil {
        panic(err)
    }

    r := gin.Default()

    // Create checkout endpoint
    r.POST("/checkout", func(c *gin.Context) {
        var req struct {
            Email     string `json:"email" binding:"required"`
            ProductID string `json:"product_id" binding:"required"`
        }

        if err := c.ShouldBindJSON(&req); err != nil {
            c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
            return
        }

        // Get or create customer
        customer, err := client.GetCustomer(c.Request.Context(), snappay.GetCustomerArgs{
            Email: req.Email,
        })
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to get customer"})
            return
        }

        // Create checkout session
        session, err := client.CreateCheckoutSession(c.Request.Context(), snappay.CreateCheckoutSessionArgs{
            CustomerID: customer.CustomerID,
            ProductID:  req.ProductID,
            SuccessURL: "https://yourapp.com/success",
            CancelURL:  stringPtr("https://yourapp.com/cancel"),
        })
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to create checkout"})
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "checkout_url": session.URL,
            "customer_id":  customer.CustomerID,
        })
    })

    // Check access endpoint
    r.GET("/access/:customer_id/:feature_id", func(c *gin.Context) {
        customerID := c.Param("customer_id")
        featureID := c.Param("feature_id")

        access, err := client.CheckAccess(c.Request.Context(), snappay.CheckAccessArgs{
            CustomerID: customerID,
            FeatureID:  featureID,
        })
        if err != nil {
            c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to check access"})
            return
        }

        c.JSON(http.StatusOK, gin.H{
            "has_access": access.HasAccess,
            "remaining":  access.UsageRemaining,
        })
    })

    r.Run(":8080")
}
```

### Echo Integration

```go
package main

import (
    "net/http"
    "github.com/labstack/echo/v4"
    "github.com/snappay/snappay-go"
)

func main() {
    client, err := snappay.NewClient(nil)
    if err != nil {
        panic(err)
    }

    e := echo.New()

    e.POST("/checkout", func(c echo.Context) error {
        var req struct {
            Email     string `json:"email"`
            ProductID string `json:"product_id"`
        }

        if err := c.Bind(&req); err != nil {
            return c.JSON(http.StatusBadRequest, map[string]string{"error": err.Error()})
        }

        customer, err := client.GetCustomer(c.Request().Context(), snappay.GetCustomerArgs{
            Email: req.Email,
        })
        if err != nil {
            return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to get customer"})
        }

        session, err := client.CreateCheckoutSession(c.Request().Context(), snappay.CreateCheckoutSessionArgs{
            CustomerID: customer.CustomerID,
            ProductID:  req.ProductID,
            SuccessURL: "https://yourapp.com/success",
        })
        if err != nil {
            return c.JSON(http.StatusInternalServerError, map[string]string{"error": "Failed to create checkout"})
        }

        return c.JSON(http.StatusOK, map[string]interface{}{
            "checkout_url": session.URL,
            "customer_id":  customer.CustomerID,
        })
    })

    e.Logger.Fatal(e.Start(":8080"))
}
```

### Fiber Integration

```go
package main

import (
    "github.com/gofiber/fiber/v2"
    "github.com/snappay/snappay-go"
)

func main() {
    client, err := snappay.NewClient(nil)
    if err != nil {
        panic(err)
    }

    app := fiber.New()

    app.Post("/checkout", func(c *fiber.Ctx) error {
        var req struct {
            Email     string `json:"email"`
            ProductID string `json:"product_id"`
        }

        if err := c.BodyParser(&req); err != nil {
            return c.Status(400).JSON(fiber.Map{"error": err.Error()})
        }

        customer, err := client.GetCustomer(c.Context(), snappay.GetCustomerArgs{
            Email: req.Email,
        })
        if err != nil {
            return c.Status(500).JSON(fiber.Map{"error": "Failed to get customer"})
        }

        session, err := client.CreateCheckoutSession(c.Context(), snappay.CreateCheckoutSessionArgs{
            CustomerID: customer.CustomerID,
            ProductID:  req.ProductID,
            SuccessURL: "https://yourapp.com/success",
        })
        if err != nil {
            return c.Status(500).JSON(fiber.Map{"error": "Failed to create checkout"})
        }

        return c.JSON(fiber.Map{
            "checkout_url": session.URL,
            "customer_id":  customer.CustomerID,
        })
    })

    app.Listen(":8080")
}
```

## Concurrency and Thread Safety

The `*Client` is safe for concurrent use across multiple goroutines:

```go
package main

import (
    "context"
    "fmt"
    "log"
    "sync"
    "github.com/snappay/snappay-go"
)

func main() {
    client, err := snappay.NewClient(nil)
    if err != nil {
        log.Fatalf("Failed to create client: %v", err)
    }

    ctx := context.Background()
    var wg sync.WaitGroup

    // Safe to use the same client from multiple goroutines
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func(id int) {
            defer wg.Done()

            customer, err := client.GetCustomer(ctx, snappay.GetCustomerArgs{
                Email: fmt.Sprintf("user%d@example.com", id),
            })
            if err != nil {
                log.Printf("Goroutine %d failed: %v", id, err)
                return
            }

            log.Printf("Goroutine %d: Customer %s", id, customer.CustomerID)
        }(i)
    }

    wg.Wait()
    log.Println("All goroutines completed")
}
```

## Type Definitions

The Go SDK provides comprehensive type definitions for all API responses and configurations:

```go
// Core configuration
type Config struct {
    APIKey     string        // Required: snappay API key
    BaseURL    string        // Optional: Custom API base URL
    HTTPClient *http.Client  // Optional: Custom HTTP client
    UserAgent  string        // Optional: Custom User-Agent header
}

// Payment provider options
type Provider string

const (
    ProviderStripe Provider = "stripe"
)

// Complete type definitions for all API operations...
```

This completes the comprehensive snappay Go SDK documentation. The SDK provides idiomatic Go patterns with channels, context support, and explicit error handling for all your payment and subscription management needs.
